# 改善版 GameManagerPlayer.js 設計

## 1. 基本情報

- **ファイル名**: GameManagerPlayer.js
- **パス**: src/service/gameManager/GameManagerPlayer.js
- **役割**: プレイヤー管理機能のGameManagerへの提供
- **形式**: Mix-in関数（GameManagerのプロトタイプを拡張）

## 2. 機能要件

GameManagerPlayer.jsは以下の機能を提供します：

1. **プレイヤー管理**
   - プレイヤーの追加と削除
   - プレイヤー情報の取得
   - プレイヤーリストの取得
   - プレイヤーIDの検証

2. **プレイヤー状態管理**
   - プレイヤーの生死状態管理
   - プレイヤーの状態効果管理（護衛、毒など）
   - プレイヤー状態の変更と通知

3. **イベント発火**
   - プレイヤー追加/削除時のイベント
   - プレイヤー死亡時のイベント
   - 状態効果変更時のイベント

4. **情報可視性制御**
   - 役職や陣営に基づく情報アクセス制御
   - 公開情報と非公開情報の分離管理

## 3. インターフェース設計

### 3.1 公開メソッド

- **addPlayer(name)**: プレイヤーを追加する
  - 戻り値: 追加されたプレイヤーのID
  - エラー: ゲーム開始後、無効な名前、プレイヤー上限超過時
  
- **removePlayer(id)**: プレイヤーを削除する
  - 戻り値: 成功時はtrue
  - エラー: ゲーム開始後、存在しないID
  
- **getPlayer(id)**: 特定のプレイヤー情報を取得する
  - 戻り値: プレイヤーオブジェクト
  - エラー: 存在しないID
  
- **getPlayerByName(name)**: 名前でプレイヤーを検索する
  - 戻り値: プレイヤーオブジェクト、または存在しない場合はnull
  
- **getAllPlayers()**: すべてのプレイヤーリストを取得する
  - 戻り値: プレイヤーオブジェクトの配列
  
- **getAlivePlayers()**: 生存プレイヤーリストを取得する
  - 戻り値: 生存プレイヤーオブジェクトの配列
  
- **getPlayerCount()**: 総プレイヤー数を取得する
  - 戻り値: プレイヤー数（数値）
  
- **getAlivePlayerCount()**: 生存プレイヤー数を取得する
  - 戻り値: 生存プレイヤー数（数値）
  
- **isPlayerAlive(id)**: プレイヤーが生存しているかを確認する
  - 戻り値: 生存していればtrue
  - エラー: 存在しないID
  
- **killPlayer(id, cause, options)**: プレイヤーを死亡させる
  - パラメータ:
    - id: 対象プレイヤーID
    - cause: 死因（'execution', 'attack', 'poison'など）
    - options: 追加オプション（公開情報設定など）
  - 戻り値: 処理結果オブジェクト
  - トランザクション: 死亡処理を原子的に実行
  
- **setPlayerStatusEffect(id, effect, value, duration)**: プレイヤーに状態効果を設定する
  - パラメータ:
    - id: 対象プレイヤーID
    - effect: 効果タイプ（'guarded', 'poisoned'など）
    - value: 効果の値
    - duration: 効果の持続期間（ターン数またはフェーズ指定）
  - 戻り値: 成功時はtrue
  
- **hasPlayerStatusEffect(id, effect)**: プレイヤーが特定の状態効果を持っているか確認する
  - 戻り値: 状態効果があればtrue
  
- **clearPlayerStatusEffects(id, [effect])**: プレイヤーの状態効果をクリアする
  - パラメータ:
    - id: 対象プレイヤーID
    - effect: クリアする効果（省略時は全効果）
  - 戻り値: 成功時はtrue
  
- **getVisiblePlayerInfo(id, viewerId)**: 指定したプレイヤーの、閲覧者から見える情報を取得
  - パラメータ:
    - id: 対象プレイヤーID
    - viewerId: 閲覧者のプレイヤーID
  - 戻り値: 閲覧可能な情報を含むプレイヤーオブジェクト

### 3.2 内部メソッド

- **#validatePlayerId(id)**: プレイヤーIDの存在と有効性を確認する
  - プライベートメソッド（ES6の#構文使用）
  - 存在しないIDの場合は例外をスロー
  
- **#checkGameState(requiredState)**: ゲーム状態を確認する
  - パラメータ:
    - requiredState: 'notStarted'/'started'/'notEnded'など
  - 条件不一致の場合は例外をスロー
  
- **#handlePlayerDeath(id, cause, options)**: プレイヤー死亡時の処理を行う
  - トランザクション的処理の実装
  - 状態変更の一貫性確保
  
- **#filterPlayerInfo(playerData, viewerId)**: プレイヤー情報を閲覧者に応じてフィルタリング
  - 役職や陣営に基づく情報開示制御

## 4. イベント設計

このモジュールが発火するイベント：

- **player.add**: プレイヤー追加時 
  - データ: `{playerId, name}`
  
- **player.remove**: プレイヤー削除時 
  - データ: `{playerId, name}`
  
- **player.death.before**: プレイヤー死亡処理前 
  - データ: `{playerId, cause, turn, executedBy}`
  
- **player.death.after**: プレイヤー死亡処理後 
  - データ: `{playerId, player, cause, turn, role, executedBy}`
  
- **player.statusEffect.add**: 状態効果追加時 
  - データ: `{playerId, effect, value, duration, turn, phase}`
  
- **player.statusEffect.remove**: 状態効果削除時 
  - データ: `{playerId, effect, turn, phase, reason}`
  
- **player.statusEffect.expired**: 状態効果期限切れ時 
  - データ: `{playerId, effect, turn, phase}`

## 5. 状態管理と一貫性

### 5.1 トランザクション処理

プレイヤーの状態変更（特に死亡処理）をトランザクション的に扱うことで、状態の一貫性を保証します：

- トランザクション開始時に現在の状態をスナップショット
- 一連の操作を実行
- 問題なければ変更をコミット、エラーが発生したらスナップショットに復元（ロールバック）
- 特に、死亡処理と役職効果発動などの複合操作で重要

これにより、複数の状態変更が途中で失敗した場合でも一貫した状態を維持できます。

### 5.2 状態効果の管理

状態効果の管理強化：

- **有効期限管理**: ターン数やフェーズに基づく自動解除
- **効果の優先順位**: 複数効果の相互作用ルール（例：護衛 > 毒）
- **効果の条件付き発動**: 特定条件下でのみ発動する効果
- **効果の相互作用**: 同時に適用された複数効果の競合解決

### 5.3 情報可視性の制御

役職と陣営に基づく情報可視性の詳細な制御：

- **基本情報**: 名前、生死状態など（常に公開）
- **役職情報**: 役職名、陣営（レギュレーションに基づき公開/非公開）
- **状態効果**: 役職能力やレギュレーションに応じて可視性を決定
- **カスタム公開情報**: 特定イベント（処刑など）時に情報開示ルールを設定可能

情報可視性はプレイヤーの役職や陣営に基づいて動的に決定され、GM（またはシステム管理者）は常にすべての情報にアクセス可能です。

## 6. パフォーマンス最適化

### 6.1 キャッシュ戦略

高頻度で呼び出されるメソッド（getAllPlayers, getAlivePlayers）のパフォーマンスを向上させるキャッシング戦略：

- タイムスタンプベースのキャッシュ管理（TTL方式）
- 短時間の連続呼び出しで同じ結果を返却
- 状態変更時にキャッシュを無効化
- ディープコピーによるキャッシュデータの保護

キャッシュタイムアウト値（TTL）は用途に応じて微調整可能です。

### 6.2 ルックアップ最適化

プレイヤー検索のパフォーマンス向上のためのルックアップテーブル：

- IDベースのマップ（高速プレイヤー取得）
- 名前ベースのマップ（名前による検索を最適化）
- 状態効果ベースのインデックス（特定の状態効果を持つプレイヤーの高速検索）

これらのデータ構造を維持することで、繰り返しアクセスのパフォーマンスが大幅に向上します。

### 6.3 バッチ処理

多数のプレイヤーへの一括操作を効率化するバッチ処理：

- 状態効果の一括解除
- 複数プレイヤーへの一括ステータス設定
- 一括操作後の単一イベント発火

大人数ゲームでは特に効果が高く、個別処理と比較して大幅なパフォーマンス向上が期待できます。

## 7. Mix-in実装方針

GameManagerPlayerMixinは以下の方針で実装されます：

- GameManagerのプロトタイプに各種メソッドを追加
- カプセル化のためのプライベートメソッド実装
- PlayerManagerへの委譲を基本としつつ、GameManager固有の処理を追加
- イベント発火とエラー処理は常にGameManagerの文脈で実行

プライベートメソッドはES6のプライベートフィールド/メソッド構文（#プレフィックス）を使用することで、適切なカプセル化を実現します。

## 8. 拡張性設計

### 8.1 プレイヤー属性の拡張メカニズム

将来的な拡張に備えたプレイヤー属性の拡張機能：

- カスタム属性の追加と取得を可能にするインターフェース
- 予約属性との競合を防ぐ検証機構
- 属性変更イベントの提供

この仕組みにより、GameManagerを修正せずにプレイヤーに新しい属性を追加できます。

### 8.2 状態効果のプラグイン設計

カスタム状態効果を登録可能なプラグインシステム：

- 効果適用、解除、条件確認、相互作用の各フェーズでのハンドラ登録
- 効果の優先順位と競合解決ルールの定義
- カスタムイベントの追加

これにより、新しい状態効果を追加する際にGameManagerPlayerを変更せずに拡張できます。

## 9. テスト戦略

### 9.1 単体テスト

- プレイヤー追加/削除基本機能
- プレイヤーリスト取得機能（キャッシュ含む）
- 状態効果設定/解除の動作
- エラーケースの検証

### 9.2 統合テスト

- プレイヤー死亡処理とイベント発火
- トランザクション処理の整合性
- 情報可視性制御の正確性
- 役職との連携動作

### 9.3 パフォーマンステスト

- 大人数ゲーム（20人以上）での動作検証
- 繰り返しアクセス時のキャッシュ効果
- バッチ処理の効率

### 9.4 モック/スタブ戦略

テストでは以下のモックとスタブを活用します：

- PlayerManagerのモック（実際の実装の代わりに使用）
- EventSystemのスパイ（イベント発火を検証）
- トランザクション処理の検証用スタブ
- エラーケースの模擬用モック

## 10. まとめ

改善版GameManagerPlayer.jsは、基本機能の提供だけでなく、以下の拡張機能を備えています：

1. **強化されたトランザクション処理**: 状態変更の一貫性を確保
2. **情報可視性の詳細制御**: 役職と陣営に基づく情報アクセス管理
3. **効率的なパフォーマンス最適化**: キャッシングとルックアップ最適化
4. **将来の拡張性確保**: プラグインシステムによる属性と状態効果の拡張
5. **堅牢なプライバシー設計**: ES6プライベートメソッドによるカプセル化

これらの改善により、大規模ゲームでのパフォーマンス、拡張性、状態管理の信頼性が向上し、より堅牢なGameManagerPlayerモジュールが実現します。
