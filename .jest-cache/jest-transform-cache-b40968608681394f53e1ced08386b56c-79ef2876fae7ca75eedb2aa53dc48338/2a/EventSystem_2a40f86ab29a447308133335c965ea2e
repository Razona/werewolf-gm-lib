5a4148c6b635eced8a3ddeb142c7683d
/**
 * EventSystem - Core event management module for the werewolf game GM support library
 *
 * This module provides the foundation for the event-driven architecture,
 * enabling communication between different modules through events.
 */

class EventSystem {
  /**
   * Creates a new EventSystem instance
   * @param {Object} options - Configuration options
   * @param {boolean} [options.enableNamespaces=true] - Enable hierarchical event namespaces
   * @param {boolean} [options.debugMode=false] - Enable debug mode with event history
   * @param {boolean} [options.enableWildcards=false] - Enable wildcard event matching
   * @param {number} [options.historyLimit=100] - Maximum number of events to keep in history
   */
  constructor(options = {}) {
    // Default options
    this.options = {
      enableNamespaces: true,
      debugMode: false,
      enableWildcards: false,
      historyLimit: 100,
      ...options
    };

    // Map to store event listeners: { eventName => [{ callback, once, priority }] }
    this.listeners = new Map();

    // Event history for debugging (only active in debug mode)
    this.eventHistory = [];

    // Flag to track if we're currently emitting an event (to handle nested emissions)
    this._emitting = false;

    // Queue for listeners to be added/removed during emission
    this._pendingAdditions = [];
    this._pendingRemovals = [];
  }

  /**
   * Register an event listener
   * @param {string} eventName - Name of the event to listen for
   * @param {Function} callback - Function to call when the event is emitted
   * @param {number} [priority=0] - Priority of the listener (higher executes first)
   * @return {EventSystem} - Returns this instance for chaining
   * @throws {Error} If eventName is not a string or callback is not a function
   */
  on(eventName, callback, priority = 0) {
    // Validate arguments
    if (typeof eventName !== 'string' || eventName.trim() === '') {
      throw new Error('Event name must be a non-empty string');
    }
    if (typeof callback !== 'function') {
      throw new Error('Callback must be a function');
    }

    // If we're currently emitting, queue the addition
    if (this._emitting) {
      this._pendingAdditions.push({
        eventName,
        callback,
        priority,
        once: false
      });
      return this;
    }

    // Get or create the listeners array for this event
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, []);
    }
    const listeners = this.listeners.get(eventName);

    // Check for duplicate listener
    const existingIndex = listeners.findIndex(listener => listener.callback === callback);
    if (existingIndex !== -1) {
      // Update the existing listener's priority
      listeners[existingIndex].priority = priority;
    } else {
      // Add the new listener
      listeners.push({
        callback,
        once: false,
        priority
      });

      // Sort listeners by priority (highest first)
      listeners.sort((a, b) => b.priority - a.priority);
    }
    return this;
  }

  /**
   * Register a one-time event listener that will be removed after execution
   * @param {string} eventName - Name of the event to listen for
   * @param {Function} callback - Function to call when the event is emitted
   * @param {number} [priority=0] - Priority of the listener (higher executes first)
   * @return {EventSystem} - Returns this instance for chaining
   * @throws {Error} If eventName is not a string or callback is not a function
   */
  once(eventName, callback, priority = 0) {
    // Validate arguments
    if (typeof eventName !== 'string' || eventName.trim() === '') {
      throw new Error('Event name must be a non-empty string');
    }
    if (typeof callback !== 'function') {
      throw new Error('Callback must be a function');
    }

    // Tracked callbacks for once - global to instance
    if (!this._onceTracker) {
      this._onceTracker = new Map();
    }

    // Each original callback gets its own wrapper
    let wrapper;

    // Check if we already have a wrapper for this callback
    if (this._onceTracker.has(callback)) {
      wrapper = this._onceTracker.get(callback);

      // Add this event name to the wrapper's tracked events
      if (!wrapper._eventNames) {
        wrapper._eventNames = new Set();
      }
      wrapper._eventNames.add(eventName);
    } else {
      // Create a special bound version that will self-remove
      wrapper = (...args) => {
        // We need to remove this listener before calling the callback
        // This prevents potential recursion issues
        const eventsToRemove = wrapper._eventNames ? [...wrapper._eventNames] : [];

        // First remove this listener from ALL events it's registered to
        eventsToRemove.forEach(name => {
          this.off(name, wrapper);
        });

        // Clean up our tracker
        this._onceTracker.delete(callback);

        // Now actually call the original callback
        return callback.apply(this, args);
      };

      // Store the original callback for comparison
      wrapper._originalCallback = callback;

      // Track event names this wrapper is registered for
      wrapper._eventNames = new Set([eventName]);

      // Store in our tracker
      this._onceTracker.set(callback, wrapper);
    }

    // If we're currently emitting, queue the addition
    if (this._emitting) {
      this._pendingAdditions.push({
        eventName,
        callback: wrapper,
        priority,
        once: true
      });
      return this;
    }

    // Get or create the listeners array for this event
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, []);
    }
    const listeners = this.listeners.get(eventName);

    // Check for duplicate listener
    const existingIndex = listeners.findIndex(listener => listener.callback === wrapper);
    if (existingIndex !== -1) {
      // Update the existing listener's priority
      listeners[existingIndex].priority = priority;
    } else {
      // Add the new listener with the wrapper as callback
      listeners.push({
        callback: wrapper,
        once: true,
        priority
      });

      // Sort listeners by priority (highest first)
      listeners.sort((a, b) => b.priority - a.priority);
    }
    return this;
  }

  /**
   * Remove an event listener
   * @param {string} eventName - Name of the event to remove listener from
   * @param {Function} [callback] - Specific callback to remove (if omitted, all listeners for the event are removed)
   * @return {EventSystem} - Returns this instance for chaining
   */
  off(eventName, callback = null) {
    // If we're currently emitting, queue the removal
    if (this._emitting) {
      this._pendingRemovals.push({
        eventName,
        callback
      });
      return this;
    }

    // If eventName doesn't exist, nothing to do
    if (!this.listeners.has(eventName)) {
      return this;
    }

    // If callback is null, remove all listeners for this event
    if (callback === null) {
      this.listeners.delete(eventName);
      return this;
    }

    // Otherwise, only remove the specific callback
    const listeners = this.listeners.get(eventName);
    const filteredListeners = listeners.filter(listener => listener.callback !== callback);
    if (filteredListeners.length === 0) {
      // If no listeners remain, remove the event entirely
      this.listeners.delete(eventName);
    } else {
      // Otherwise, update the listeners array
      this.listeners.set(eventName, filteredListeners);
    }
    return this;
  }

  /**
   * Emit an event to all registered listeners
   * @param {string} eventName - Name of the event to emit
   * @param {*} [data] - Data to pass to the listeners
   * @return {boolean} - True if the event had listeners, false otherwise
   */
  emit(eventName, data) {
    // Mark that we're emitting an event
    const wasEmitting = this._emitting;
    this._emitting = true;

    // Track whether any listeners were called
    let listenersCalled = false;
    try {
      // Add to history if debug mode is enabled
      if (this.options.debugMode) {
        this._addToHistory(eventName, data);
      }

      // Get all event names to emit based on the options
      const eventNamesToEmit = this._getEventNamesForEmission(eventName);

      // リスナーを呼び出す前にトラッキング用のセットを作成
      // これにより、同じイベント発火内での重複実行を防止
      const calledListeners = new Set();
      const listenersToRemove = [];

      // Emit to each matched event name
      for (const name of eventNamesToEmit) {
        if (this.listeners.has(name)) {
          // リスナーのリストをコピーして処理（途中で削除される可能性があるため）
          const listeners = [...this.listeners.get(name)];

          // Call each listener
          for (const listener of listeners) {
            const {
              callback,
              once
            } = listener;

            // このイベント発火内で既に呼び出されたリスナーはスキップ
            if (calledListeners.has(callback)) {
              continue;
            }
            try {
              // 呼び出し前にセットに追加
              calledListeners.add(callback);

              // Call the listener with the event data
              callback(data);
              listenersCalled = true;

              // If it's a once listener, mark it for removal
              // Note: The wrapper should have auto-removed itself already
              // This is just a safety net
              if (once) {
                listenersToRemove.push({
                  name,
                  callback
                });
              }
            } catch (error) {
              // Log the error but continue with other listeners
              console.error(`Error in event listener for '${name}':`, error);
            }
          }
        }
      }

      // 全てのリスナー実行後に、一度だけ削除処理を行う
      // これは主にセーフティネットとして機能します
      for (const {
        name,
        callback
      } of listenersToRemove) {
        // リスナーを削除
        if (this.listeners.has(name)) {
          const listeners = this.listeners.get(name);
          const updatedListeners = listeners.filter(l => l.callback !== callback);
          if (updatedListeners.length === 0) {
            this.listeners.delete(name);
          } else {
            this.listeners.set(name, updatedListeners);
          }
        }
      }

      // Process pending additions and removals (if we're not in a nested emit)
      if (!wasEmitting) {
        this._processPendingOperations();
      }
      return listenersCalled;
    } finally {
      // Only reset the emitting flag if we're the outermost emit call
      if (!wasEmitting) {
        this._emitting = false;
      }
    }
  }

  /**
   * Check if an event has any listeners
   * @param {string} eventName - Name of the event to check
   * @return {boolean} - True if the event has listeners, false otherwise
   */
  hasListeners(eventName) {
    // Direct match
    if (this.listeners.has(eventName) && this.listeners.get(eventName).length > 0) {
      return true;
    }

    // If wildcards are enabled, check for wildcard matches
    if (this.options.enableWildcards) {
      // 最適化: 最大チェック数を制限
      let checked = 0;
      const maxToCheck = 100;
      for (const [name, listeners] of this.listeners.entries()) {
        if (++checked > maxToCheck) break;
        if (listeners.length > 0 && name.includes('*') && this._matchesWildcard(name, eventName)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get the number of listeners for an event
   * @param {string} eventName - Name of the event to check
   * @return {number} - Number of listeners for the event
   */
  listenerCount(eventName) {
    let count = 0;

    // Direct match
    if (this.listeners.has(eventName)) {
      count += this.listeners.get(eventName).length;
    }

    // If wildcards are enabled, check for wildcard matches
    if (this.options.enableWildcards) {
      // 最適化: 最大チェック数を制限
      let checked = 0;
      const maxToCheck = 100;
      for (const [name, listeners] of this.listeners.entries()) {
        if (++checked > maxToCheck) break;
        if (name !== eventName && name.includes('*') && this._matchesWildcard(name, eventName)) {
          count += listeners.length;
        }
      }
    }
    return count;
  }

  /**
   * Get all registered event names
   * @return {string[]} - Array of registered event names
   */
  eventNames() {
    return Array.from(this.listeners.keys());
  }

  /**
   * Get the recent event history (only available in debug mode)
   * @param {number} [limit=10] - Maximum number of events to return
   * @return {Array} - Array of recent events or empty array if debug mode is disabled
   */
  getEventHistory(limit = 10) {
    if (!this.options.debugMode) {
      return [];
    }
    const actualLimit = Math.min(limit, this.eventHistory.length);
    return this.eventHistory.slice(-actualLimit);
  }

  /**
   * Clear all event listeners
   * @return {EventSystem} - Returns this instance for chaining
   */
  removeAllListeners() {
    this.listeners.clear();
    return this;
  }

  /**
   * Process pending listener additions and removals
   * @private
   */
  _processPendingOperations() {
    // 最適化: 大量のペンディング操作がある場合のガード
    const maxOperations = 1000;

    // Process removals first to avoid issues with additions that would be immediately removed
    const removalsToProcess = Math.min(this._pendingRemovals.length, maxOperations);
    for (let i = 0; i < removalsToProcess; i++) {
      const {
        eventName,
        callback
      } = this._pendingRemovals[i];
      this.off(eventName, callback);
    }

    // 処理した分だけ配列から削除
    if (removalsToProcess === this._pendingRemovals.length) {
      this._pendingRemovals = [];
    } else {
      this._pendingRemovals = this._pendingRemovals.slice(removalsToProcess);
    }

    // Then process additions
    const additionsToProcess = Math.min(this._pendingAdditions.length, maxOperations);
    for (let i = 0; i < additionsToProcess; i++) {
      const {
        eventName,
        callback,
        priority,
        once
      } = this._pendingAdditions[i];
      if (once) {
        this.once(eventName, callback, priority);
      } else {
        this.on(eventName, callback, priority);
      }
    }

    // 処理した分だけ配列から削除
    if (additionsToProcess === this._pendingAdditions.length) {
      this._pendingAdditions = [];
    } else {
      this._pendingAdditions = this._pendingAdditions.slice(additionsToProcess);
    }
  }

  /**
   * Add an event to the history
   * @param {string} eventName - Name of the emitted event
   * @param {*} data - Data passed with the event
   * @private
   */
  _addToHistory(eventName, data) {
    // Add to history with timestamp
    this.eventHistory.push({
      eventName,
      data,
      timestamp: new Date()
    });

    // Trim history if it exceeds the limit
    if (this.eventHistory.length > this.options.historyLimit) {
      this.eventHistory.shift();
    }
  }

  /**
   * Get all event names to emit based on the original event and options
   * @param {string} eventName - The original event name
   * @return {string[]} - Array of event names to emit
   * @private
   */
  _getEventNamesForEmission(eventName) {
    const eventNames = [eventName];

    // Add namespace parent events if enabled
    if (this.options.enableNamespaces && eventName.includes('.')) {
      const parts = eventName.split('.');
      // 最適化: 一度に全部を計算せず徐々に親名前空間を構築
      let parentName = '';
      for (let i = 0; i < parts.length - 1; i++) {
        parentName = parentName ? `${parentName}.${parts[i]}` : parts[i];
        eventNames.push(parentName);
      }
    }

    // 最適化: ワイルドカードが有効な場合は、必要なリスナーのみマッチングする
    if (this.options.enableWildcards) {
      // 最適化: リスナーの数が多すぎる場合は制限する
      const maxListenersToCheck = 100;
      let checkedCount = 0;
      for (const name of this.listeners.keys()) {
        // ワイルドカード文字を含む場合のみチェック
        if (!name.includes('*')) continue;

        // 処理済みのイベント名はスキップ
        if (eventNames.includes(name)) continue;

        // 最大制限に達したら停止
        if (++checkedCount > maxListenersToCheck) {
          break;
        }

        // ワイルドカードパターンの簡易チェック
        if (this._matchesWildcard(name, eventName)) {
          eventNames.push(name);
        }
      }
    }
    return eventNames;
  }

  /**
   * Check if a wildcard pattern matches an event name
   * @param {string} pattern - The wildcard pattern to check
   * @param {string} eventName - The event name to match against
   * @return {boolean} - True if the pattern matches the event name
   * @private
   */
  _matchesWildcard(pattern, eventName) {
    // パターンや名前が異常に長い場合はマッチングを諦める（安全対策）
    if (pattern.length > 1000 || eventName.length > 1000) {
      return false;
    }

    // 単純なチェック
    if (pattern === eventName) {
      return true;
    }

    // 単純なワイルドカードチェック
    if (pattern === '*') {
      return !eventName.includes('.');
    }
    if (pattern === '**') {
      return true;
    }

    // 複数階層のワイルドカード (**) の処理
    if (pattern.includes('**')) {
      const parts = pattern.split('**');

      // 最適化: 最大2つのパートのみをサポート
      if (parts.length > 2) {
        return false;
      }

      // パターンが 'game.**' のような形式の場合
      if (parts.length === 2 && parts[1] === '') {
        return eventName.startsWith(parts[0]);
      }

      // パターンが '**.end' のような形式の場合
      if (parts.length === 2 && parts[0] === '') {
        return eventName.endsWith(parts[1]);
      }

      // パターンが 'start.**.end' のような形式の場合
      if (parts.length === 2) {
        return eventName.startsWith(parts[0]) && eventName.endsWith(parts[1]);
      }
    }

    // 単一階層のワイルドカード (*) の処理
    if (pattern.includes('*') && !pattern.includes('**')) {
      // 正規表現を使わない最適化された方法
      const patternParts = pattern.split('.');
      const eventParts = eventName.split('.');
      if (patternParts.length !== eventParts.length) {
        return false;
      }
      for (let i = 0; i < patternParts.length; i++) {
        if (patternParts[i] === '*') {
          continue; // ワイルドカードは何にもマッチする
        }
        if (patternParts[i] !== eventParts[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
}
module.exports = EventSystem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFdmVudFN5c3RlbSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImVuYWJsZU5hbWVzcGFjZXMiLCJkZWJ1Z01vZGUiLCJlbmFibGVXaWxkY2FyZHMiLCJoaXN0b3J5TGltaXQiLCJsaXN0ZW5lcnMiLCJNYXAiLCJldmVudEhpc3RvcnkiLCJfZW1pdHRpbmciLCJfcGVuZGluZ0FkZGl0aW9ucyIsIl9wZW5kaW5nUmVtb3ZhbHMiLCJvbiIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwicHJpb3JpdHkiLCJ0cmltIiwiRXJyb3IiLCJwdXNoIiwib25jZSIsImhhcyIsInNldCIsImdldCIsImV4aXN0aW5nSW5kZXgiLCJmaW5kSW5kZXgiLCJsaXN0ZW5lciIsInNvcnQiLCJhIiwiYiIsIl9vbmNlVHJhY2tlciIsIndyYXBwZXIiLCJfZXZlbnROYW1lcyIsIlNldCIsImFkZCIsImFyZ3MiLCJldmVudHNUb1JlbW92ZSIsImZvckVhY2giLCJuYW1lIiwib2ZmIiwiZGVsZXRlIiwiYXBwbHkiLCJfb3JpZ2luYWxDYWxsYmFjayIsImZpbHRlcmVkTGlzdGVuZXJzIiwiZmlsdGVyIiwibGVuZ3RoIiwiZW1pdCIsImRhdGEiLCJ3YXNFbWl0dGluZyIsImxpc3RlbmVyc0NhbGxlZCIsIl9hZGRUb0hpc3RvcnkiLCJldmVudE5hbWVzVG9FbWl0IiwiX2dldEV2ZW50TmFtZXNGb3JFbWlzc2lvbiIsImNhbGxlZExpc3RlbmVycyIsImxpc3RlbmVyc1RvUmVtb3ZlIiwiZXJyb3IiLCJjb25zb2xlIiwidXBkYXRlZExpc3RlbmVycyIsImwiLCJfcHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zIiwiaGFzTGlzdGVuZXJzIiwiY2hlY2tlZCIsIm1heFRvQ2hlY2siLCJlbnRyaWVzIiwiaW5jbHVkZXMiLCJfbWF0Y2hlc1dpbGRjYXJkIiwibGlzdGVuZXJDb3VudCIsImNvdW50IiwiZXZlbnROYW1lcyIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJnZXRFdmVudEhpc3RvcnkiLCJsaW1pdCIsImFjdHVhbExpbWl0IiwiTWF0aCIsIm1pbiIsInNsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiY2xlYXIiLCJtYXhPcGVyYXRpb25zIiwicmVtb3ZhbHNUb1Byb2Nlc3MiLCJpIiwiYWRkaXRpb25zVG9Qcm9jZXNzIiwidGltZXN0YW1wIiwiRGF0ZSIsInNoaWZ0IiwicGFydHMiLCJzcGxpdCIsInBhcmVudE5hbWUiLCJtYXhMaXN0ZW5lcnNUb0NoZWNrIiwiY2hlY2tlZENvdW50IiwicGF0dGVybiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInBhdHRlcm5QYXJ0cyIsImV2ZW50UGFydHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiRXZlbnRTeXN0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFdmVudFN5c3RlbSAtIENvcmUgZXZlbnQgbWFuYWdlbWVudCBtb2R1bGUgZm9yIHRoZSB3ZXJld29sZiBnYW1lIEdNIHN1cHBvcnQgbGlicmFyeVxuICpcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBmb3VuZGF0aW9uIGZvciB0aGUgZXZlbnQtZHJpdmVuIGFyY2hpdGVjdHVyZSxcbiAqIGVuYWJsaW5nIGNvbW11bmljYXRpb24gYmV0d2VlbiBkaWZmZXJlbnQgbW9kdWxlcyB0aHJvdWdoIGV2ZW50cy5cbiAqL1xuXG5jbGFzcyBFdmVudFN5c3RlbSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50U3lzdGVtIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlTmFtZXNwYWNlcz10cnVlXSAtIEVuYWJsZSBoaWVyYXJjaGljYWwgZXZlbnQgbmFtZXNwYWNlc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlYnVnTW9kZT1mYWxzZV0gLSBFbmFibGUgZGVidWcgbW9kZSB3aXRoIGV2ZW50IGhpc3RvcnlcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVXaWxkY2FyZHM9ZmFsc2VdIC0gRW5hYmxlIHdpbGRjYXJkIGV2ZW50IG1hdGNoaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oaXN0b3J5TGltaXQ9MTAwXSAtIE1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB0byBrZWVwIGluIGhpc3RvcnlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIERlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZU5hbWVzcGFjZXM6IHRydWUsXG4gICAgICBkZWJ1Z01vZGU6IGZhbHNlLFxuICAgICAgZW5hYmxlV2lsZGNhcmRzOiBmYWxzZSwgXG4gICAgICBoaXN0b3J5TGltaXQ6IDEwMCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gTWFwIHRvIHN0b3JlIGV2ZW50IGxpc3RlbmVyczogeyBldmVudE5hbWUgPT4gW3sgY2FsbGJhY2ssIG9uY2UsIHByaW9yaXR5IH1dIH1cbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIEV2ZW50IGhpc3RvcnkgZm9yIGRlYnVnZ2luZyAob25seSBhY3RpdmUgaW4gZGVidWcgbW9kZSlcbiAgICB0aGlzLmV2ZW50SGlzdG9yeSA9IFtdO1xuXG4gICAgLy8gRmxhZyB0byB0cmFjayBpZiB3ZSdyZSBjdXJyZW50bHkgZW1pdHRpbmcgYW4gZXZlbnQgKHRvIGhhbmRsZSBuZXN0ZWQgZW1pc3Npb25zKVxuICAgIHRoaXMuX2VtaXR0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBRdWV1ZSBmb3IgbGlzdGVuZXJzIHRvIGJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIGVtaXNzaW9uXG4gICAgdGhpcy5fcGVuZGluZ0FkZGl0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFscyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MF0gLSBQcmlvcml0eSBvZiB0aGUgbGlzdGVuZXIgKGhpZ2hlciBleGVjdXRlcyBmaXJzdClcbiAgICogQHJldHVybiB7RXZlbnRTeXN0ZW19IC0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgZXZlbnROYW1lIGlzIG5vdCBhIHN0cmluZyBvciBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblxuICAgKi9cbiAgb24oZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHkgPSAwKSB7XG4gICAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgIT09ICdzdHJpbmcnIHx8IGV2ZW50TmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBlbWl0dGluZywgcXVldWUgdGhlIGFkZGl0aW9uXG4gICAgaWYgKHRoaXMuX2VtaXR0aW5nKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nQWRkaXRpb25zLnB1c2goeyBldmVudE5hbWUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZTogZmFsc2UgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoaXMgZXZlbnRcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG5cbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGxpc3RlbmVyXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgobGlzdGVuZXIgPT4gbGlzdGVuZXIuY2FsbGJhY2sgPT09IGNhbGxiYWNrKTtcbiAgICBpZiAoZXhpc3RpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgbGlzdGVuZXIncyBwcmlvcml0eVxuICAgICAgbGlzdGVuZXJzW2V4aXN0aW5nSW5kZXhdLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCB0aGUgbmV3IGxpc3RlbmVyXG4gICAgICBsaXN0ZW5lcnMucHVzaCh7IGNhbGxiYWNrLCBvbmNlOiBmYWxzZSwgcHJpb3JpdHkgfSk7XG5cbiAgICAgIC8vIFNvcnQgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IChoaWdoZXN0IGZpcnN0KVxuICAgICAgbGlzdGVuZXJzLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG9uZS10aW1lIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGV4ZWN1dGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTBdIC0gUHJpb3JpdHkgb2YgdGhlIGxpc3RlbmVyIChoaWdoZXIgZXhlY3V0ZXMgZmlyc3QpXG4gICAqIEByZXR1cm4ge0V2ZW50U3lzdGVtfSAtIFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGV2ZW50TmFtZSBpcyBub3QgYSBzdHJpbmcgb3IgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cbiAgICovXG4gIG9uY2UoZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHkgPSAwKSB7XG4gICAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgIT09ICdzdHJpbmcnIHx8IGV2ZW50TmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcmFja2VkIGNhbGxiYWNrcyBmb3Igb25jZSAtIGdsb2JhbCB0byBpbnN0YW5jZVxuICAgIGlmICghdGhpcy5fb25jZVRyYWNrZXIpIHtcbiAgICAgIHRoaXMuX29uY2VUcmFja2VyID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBFYWNoIG9yaWdpbmFsIGNhbGxiYWNrIGdldHMgaXRzIG93biB3cmFwcGVyXG4gICAgbGV0IHdyYXBwZXI7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgd3JhcHBlciBmb3IgdGhpcyBjYWxsYmFja1xuICAgIGlmICh0aGlzLl9vbmNlVHJhY2tlci5oYXMoY2FsbGJhY2spKSB7XG4gICAgICB3cmFwcGVyID0gdGhpcy5fb25jZVRyYWNrZXIuZ2V0KGNhbGxiYWNrKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRoaXMgZXZlbnQgbmFtZSB0byB0aGUgd3JhcHBlcidzIHRyYWNrZWQgZXZlbnRzXG4gICAgICBpZiAoIXdyYXBwZXIuX2V2ZW50TmFtZXMpIHtcbiAgICAgICAgd3JhcHBlci5fZXZlbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIHdyYXBwZXIuX2V2ZW50TmFtZXMuYWRkKGV2ZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHNwZWNpYWwgYm91bmQgdmVyc2lvbiB0aGF0IHdpbGwgc2VsZi1yZW1vdmVcbiAgICAgIHdyYXBwZXIgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGlzIGxpc3RlbmVyIGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHBvdGVudGlhbCByZWN1cnNpb24gaXNzdWVzXG4gICAgICAgIGNvbnN0IGV2ZW50c1RvUmVtb3ZlID0gd3JhcHBlci5fZXZlbnROYW1lcyA/IFsuLi53cmFwcGVyLl9ldmVudE5hbWVzXSA6IFtdO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIHRoaXMgbGlzdGVuZXIgZnJvbSBBTEwgZXZlbnRzIGl0J3MgcmVnaXN0ZXJlZCB0b1xuICAgICAgICBldmVudHNUb1JlbW92ZS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKG5hbWUsIHdyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFuIHVwIG91ciB0cmFja2VyXG4gICAgICAgIHRoaXMuX29uY2VUcmFja2VyLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIFxuICAgICAgICAvLyBOb3cgYWN0dWFsbHkgY2FsbCB0aGUgb3JpZ2luYWwgY2FsbGJhY2tcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZvciBjb21wYXJpc29uXG4gICAgICB3cmFwcGVyLl9vcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBcbiAgICAgIC8vIFRyYWNrIGV2ZW50IG5hbWVzIHRoaXMgd3JhcHBlciBpcyByZWdpc3RlcmVkIGZvclxuICAgICAgd3JhcHBlci5fZXZlbnROYW1lcyA9IG5ldyBTZXQoW2V2ZW50TmFtZV0pO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSBpbiBvdXIgdHJhY2tlclxuICAgICAgdGhpcy5fb25jZVRyYWNrZXIuc2V0KGNhbGxiYWNrLCB3cmFwcGVyKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZW1pdHRpbmcsIHF1ZXVlIHRoZSBhZGRpdGlvblxuICAgIGlmICh0aGlzLl9lbWl0dGluZykge1xuICAgICAgdGhpcy5fcGVuZGluZ0FkZGl0aW9ucy5wdXNoKHsgZXZlbnROYW1lLCBjYWxsYmFjazogd3JhcHBlciwgcHJpb3JpdHksIG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoaXMgZXZlbnRcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG5cbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGxpc3RlbmVyXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgobGlzdGVuZXIgPT4gbGlzdGVuZXIuY2FsbGJhY2sgPT09IHdyYXBwZXIpO1xuICAgIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBsaXN0ZW5lcidzIHByaW9yaXR5XG4gICAgICBsaXN0ZW5lcnNbZXhpc3RpbmdJbmRleF0ucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHRoZSBuZXcgbGlzdGVuZXIgd2l0aCB0aGUgd3JhcHBlciBhcyBjYWxsYmFja1xuICAgICAgbGlzdGVuZXJzLnB1c2goeyBjYWxsYmFjazogd3JhcHBlciwgb25jZTogdHJ1ZSwgcHJpb3JpdHkgfSk7XG5cbiAgICAgIC8vIFNvcnQgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IChoaWdoZXN0IGZpcnN0KVxuICAgICAgbGlzdGVuZXJzLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBsaXN0ZW5lciBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBTcGVjaWZpYyBjYWxsYmFjayB0byByZW1vdmUgKGlmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCBhcmUgcmVtb3ZlZClcbiAgICogQHJldHVybiB7RXZlbnRTeXN0ZW19IC0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgb2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGVtaXR0aW5nLCBxdWV1ZSB0aGUgcmVtb3ZhbFxuICAgIGlmICh0aGlzLl9lbWl0dGluZykge1xuICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWxzLnB1c2goeyBldmVudE5hbWUsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gSWYgZXZlbnROYW1lIGRvZXNuJ3QgZXhpc3QsIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJZiBjYWxsYmFjayBpcyBudWxsLCByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhpcyBldmVudFxuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIG9ubHkgcmVtb3ZlIHRoZSBzcGVjaWZpYyBjYWxsYmFja1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgIGNvbnN0IGZpbHRlcmVkTGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYWxsYmFjayAhPT0gY2FsbGJhY2spO1xuXG4gICAgaWYgKGZpbHRlcmVkTGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgbm8gbGlzdGVuZXJzIHJlbWFpbiwgcmVtb3ZlIHRoZSBldmVudCBlbnRpcmVseVxuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXBkYXRlIHRoZSBsaXN0ZW5lcnMgYXJyYXlcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNldChldmVudE5hbWUsIGZpbHRlcmVkTGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIERhdGEgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBlbWl0KGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIC8vIE1hcmsgdGhhdCB3ZSdyZSBlbWl0dGluZyBhbiBldmVudFxuICAgIGNvbnN0IHdhc0VtaXR0aW5nID0gdGhpcy5fZW1pdHRpbmc7XG4gICAgdGhpcy5fZW1pdHRpbmcgPSB0cnVlO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkXG4gICAgbGV0IGxpc3RlbmVyc0NhbGxlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkZCB0byBoaXN0b3J5IGlmIGRlYnVnIG1vZGUgaXMgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgdGhpcy5fYWRkVG9IaXN0b3J5KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBhbGwgZXZlbnQgbmFtZXMgdG8gZW1pdCBiYXNlZCBvbiB0aGUgb3B0aW9uc1xuICAgICAgY29uc3QgZXZlbnROYW1lc1RvRW1pdCA9IHRoaXMuX2dldEV2ZW50TmFtZXNGb3JFbWlzc2lvbihldmVudE5hbWUpO1xuICAgICAgXG4gICAgICAvLyDjg6rjgrnjg4rjg7zjgpLlkbzjgbPlh7rjgZnliY3jgavjg4jjg6njg4Pjgq3jg7PjgrDnlKjjga7jgrvjg4Pjg4jjgpLkvZzmiJBcbiAgICAgIC8vIOOBk+OCjOOBq+OCiOOCiuOAgeWQjOOBmOOCpOODmeODs+ODiOeZuueBq+WGheOBp+OBrumHjeikh+Wun+ihjOOCkumYsuatolxuICAgICAgY29uc3QgY2FsbGVkTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgLy8gRW1pdCB0byBlYWNoIG1hdGNoZWQgZXZlbnQgbmFtZVxuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGV2ZW50TmFtZXNUb0VtaXQpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIC8vIOODquOCueODiuODvOOBruODquOCueODiOOCkuOCs+ODlOODvOOBl+OBpuWHpueQhu+8iOmAlOS4reOBp+WJiumZpOOBleOCjOOCi+WPr+iDveaAp+OBjOOBguOCi+OBn+OCge+8iVxuICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi50aGlzLmxpc3RlbmVycy5nZXQobmFtZSldO1xuXG4gICAgICAgICAgLy8gQ2FsbCBlYWNoIGxpc3RlbmVyXG4gICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9uY2UgfSA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyDjgZPjga7jgqTjg5njg7Pjg4jnmbrngavlhoXjgafml6LjgavlkbzjgbPlh7rjgZXjgozjgZ/jg6rjgrnjg4rjg7zjga/jgrnjgq3jg4Pjg5dcbiAgICAgICAgICAgIGlmIChjYWxsZWRMaXN0ZW5lcnMuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8g5ZG844Gz5Ye644GX5YmN44Gr44K744OD44OI44Gr6L+95YqgXG4gICAgICAgICAgICAgIGNhbGxlZExpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgbGlzdGVuZXIgd2l0aCB0aGUgZXZlbnQgZGF0YVxuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXJzQ2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgb25jZSBsaXN0ZW5lciwgbWFyayBpdCBmb3IgcmVtb3ZhbFxuICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgd3JhcHBlciBzaG91bGQgaGF2ZSBhdXRvLXJlbW92ZWQgaXRzZWxmIGFscmVhZHlcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldFxuICAgICAgICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1RvUmVtb3ZlLnB1c2goeyBuYW1lLCBjYWxsYmFjayB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gTG9nIHRoZSBlcnJvciBidXQgY29udGludWUgd2l0aCBvdGhlciBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gZXZlbnQgbGlzdGVuZXIgZm9yICcke25hbWV9JzpgLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIOWFqOOBpuOBruODquOCueODiuODvOWun+ihjOW+jOOBq+OAgeS4gOW6puOBoOOBkeWJiumZpOWHpueQhuOCkuihjOOBhlxuICAgICAgLy8g44GT44KM44Gv5Li744Gr44K744O844OV44OG44Kj44ON44OD44OI44Go44GX44Gm5qmf6IO944GX44G+44GZXG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgY2FsbGJhY2sgfSBvZiBsaXN0ZW5lcnNUb1JlbW92ZSkge1xuICAgICAgICAvLyDjg6rjgrnjg4rjg7zjgpLliYrpmaRcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldChuYW1lKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkTGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihsID0+IGwuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodXBkYXRlZExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KG5hbWUsIHVwZGF0ZWRMaXN0ZW5lcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQcm9jZXNzIHBlbmRpbmcgYWRkaXRpb25zIGFuZCByZW1vdmFscyAoaWYgd2UncmUgbm90IGluIGEgbmVzdGVkIGVtaXQpXG4gICAgICBpZiAoIXdhc0VtaXR0aW5nKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NQZW5kaW5nT3BlcmF0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdGVuZXJzQ2FsbGVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBPbmx5IHJlc2V0IHRoZSBlbWl0dGluZyBmbGFnIGlmIHdlJ3JlIHRoZSBvdXRlcm1vc3QgZW1pdCBjYWxsXG4gICAgICBpZiAoIXdhc0VtaXR0aW5nKSB7XG4gICAgICAgIHRoaXMuX2VtaXR0aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGV2ZW50IGhhcyBhbnkgbGlzdGVuZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGV2ZW50IGhhcyBsaXN0ZW5lcnMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIC8vIERpcmVjdCBtYXRjaFxuICAgIGlmICh0aGlzLmxpc3RlbmVycy5oYXMoZXZlbnROYW1lKSAmJiB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnROYW1lKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3aWxkY2FyZHMgYXJlIGVuYWJsZWQsIGNoZWNrIGZvciB3aWxkY2FyZCBtYXRjaGVzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVXaWxkY2FyZHMpIHtcbiAgICAgIC8vIOacgOmBqeWMljog5pyA5aSn44OB44Kn44OD44Kv5pWw44KS5Yi26ZmQXG4gICAgICBsZXQgY2hlY2tlZCA9IDA7XG4gICAgICBjb25zdCBtYXhUb0NoZWNrID0gMTAwO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCBsaXN0ZW5lcnNdIG9mIHRoaXMubGlzdGVuZXJzLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoKytjaGVja2VkID4gbWF4VG9DaGVjaykgYnJlYWs7XG4gICAgICAgIFxuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDAgJiYgbmFtZS5pbmNsdWRlcygnKicpICYmIHRoaXMuX21hdGNoZXNXaWxkY2FyZChuYW1lLCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciBhbiBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gY2hlY2tcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIE51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudFxuICAgKi9cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgLy8gRGlyZWN0IG1hdGNoXG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICBjb3VudCArPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnROYW1lKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSWYgd2lsZGNhcmRzIGFyZSBlbmFibGVkLCBjaGVjayBmb3Igd2lsZGNhcmQgbWF0Y2hlc1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlV2lsZGNhcmRzKSB7XG4gICAgICAvLyDmnIDpganljJY6IOacgOWkp+ODgeOCp+ODg+OCr+aVsOOCkuWItumZkFxuICAgICAgbGV0IGNoZWNrZWQgPSAwO1xuICAgICAgY29uc3QgbWF4VG9DaGVjayA9IDEwMDtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBbbmFtZSwgbGlzdGVuZXJzXSBvZiB0aGlzLmxpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKCsrY2hlY2tlZCA+IG1heFRvQ2hlY2spIGJyZWFrO1xuICAgICAgICBcbiAgICAgICAgaWYgKG5hbWUgIT09IGV2ZW50TmFtZSAmJiBuYW1lLmluY2x1ZGVzKCcqJykgJiYgdGhpcy5fbWF0Y2hlc1dpbGRjYXJkKG5hbWUsIGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICBjb3VudCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgcmVnaXN0ZXJlZCBldmVudCBuYW1lc1xuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gLSBBcnJheSBvZiByZWdpc3RlcmVkIGV2ZW50IG5hbWVzXG4gICAqL1xuICBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzLmtleXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZWNlbnQgZXZlbnQgaGlzdG9yeSAob25seSBhdmFpbGFibGUgaW4gZGVidWcgbW9kZSlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdD0xMF0gLSBNYXhpbXVtIG51bWJlciBvZiBldmVudHMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIEFycmF5IG9mIHJlY2VudCBldmVudHMgb3IgZW1wdHkgYXJyYXkgaWYgZGVidWcgbW9kZSBpcyBkaXNhYmxlZFxuICAgKi9cbiAgZ2V0RXZlbnRIaXN0b3J5KGxpbWl0ID0gMTApIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWJ1Z01vZGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3R1YWxMaW1pdCA9IE1hdGgubWluKGxpbWl0LCB0aGlzLmV2ZW50SGlzdG9yeS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLmV2ZW50SGlzdG9yeS5zbGljZSgtYWN0dWFsTGltaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICogQHJldHVybiB7RXZlbnRTeXN0ZW19IC0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBwZW5kaW5nIGxpc3RlbmVyIGFkZGl0aW9ucyBhbmQgcmVtb3ZhbHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzUGVuZGluZ09wZXJhdGlvbnMoKSB7XG4gICAgLy8g5pyA6YGp5YyWOiDlpKfph4/jga7jg5rjg7Pjg4fjgqPjg7PjgrDmk43kvZzjgYzjgYLjgovloLTlkIjjga7jgqzjg7zjg4lcbiAgICBjb25zdCBtYXhPcGVyYXRpb25zID0gMTAwMDtcbiAgICBcbiAgICAvLyBQcm9jZXNzIHJlbW92YWxzIGZpcnN0IHRvIGF2b2lkIGlzc3VlcyB3aXRoIGFkZGl0aW9ucyB0aGF0IHdvdWxkIGJlIGltbWVkaWF0ZWx5IHJlbW92ZWRcbiAgICBjb25zdCByZW1vdmFsc1RvUHJvY2VzcyA9IE1hdGgubWluKHRoaXMuX3BlbmRpbmdSZW1vdmFscy5sZW5ndGgsIG1heE9wZXJhdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZhbHNUb1Byb2Nlc3M7IGkrKykge1xuICAgICAgY29uc3QgeyBldmVudE5hbWUsIGNhbGxiYWNrIH0gPSB0aGlzLl9wZW5kaW5nUmVtb3ZhbHNbaV07XG4gICAgICB0aGlzLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgXG4gICAgLy8g5Yem55CG44GX44Gf5YiG44Gg44GR6YWN5YiX44GL44KJ5YmK6ZmkXG4gICAgaWYgKHJlbW92YWxzVG9Qcm9jZXNzID09PSB0aGlzLl9wZW5kaW5nUmVtb3ZhbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVtb3ZhbHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWxzID0gdGhpcy5fcGVuZGluZ1JlbW92YWxzLnNsaWNlKHJlbW92YWxzVG9Qcm9jZXNzKTtcbiAgICB9XG5cbiAgICAvLyBUaGVuIHByb2Nlc3MgYWRkaXRpb25zXG4gICAgY29uc3QgYWRkaXRpb25zVG9Qcm9jZXNzID0gTWF0aC5taW4odGhpcy5fcGVuZGluZ0FkZGl0aW9ucy5sZW5ndGgsIG1heE9wZXJhdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkaXRpb25zVG9Qcm9jZXNzOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHksIG9uY2UgfSA9IHRoaXMuX3BlbmRpbmdBZGRpdGlvbnNbaV07XG4gICAgICBpZiAob25jZSkge1xuICAgICAgICB0aGlzLm9uY2UoZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIGNhbGxiYWNrLCBwcmlvcml0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIOWHpueQhuOBl+OBn+WIhuOBoOOBkemFjeWIl+OBi+OCieWJiumZpFxuICAgIGlmIChhZGRpdGlvbnNUb1Byb2Nlc3MgPT09IHRoaXMuX3BlbmRpbmdBZGRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nQWRkaXRpb25zID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdBZGRpdGlvbnMgPSB0aGlzLl9wZW5kaW5nQWRkaXRpb25zLnNsaWNlKGFkZGl0aW9uc1RvUHJvY2Vzcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCB0byB0aGUgaGlzdG9yeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZW1pdHRlZCBldmVudFxuICAgKiBAcGFyYW0geyp9IGRhdGEgLSBEYXRhIHBhc3NlZCB3aXRoIHRoZSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZFRvSGlzdG9yeShldmVudE5hbWUsIGRhdGEpIHtcbiAgICAvLyBBZGQgdG8gaGlzdG9yeSB3aXRoIHRpbWVzdGFtcFxuICAgIHRoaXMuZXZlbnRIaXN0b3J5LnB1c2goe1xuICAgICAgZXZlbnROYW1lLFxuICAgICAgZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgIH0pO1xuXG4gICAgLy8gVHJpbSBoaXN0b3J5IGlmIGl0IGV4Y2VlZHMgdGhlIGxpbWl0XG4gICAgaWYgKHRoaXMuZXZlbnRIaXN0b3J5Lmxlbmd0aCA+IHRoaXMub3B0aW9ucy5oaXN0b3J5TGltaXQpIHtcbiAgICAgIHRoaXMuZXZlbnRIaXN0b3J5LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZXZlbnQgbmFtZXMgdG8gZW1pdCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgZXZlbnQgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBvcmlnaW5hbCBldmVudCBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfSAtIEFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGVtaXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRFdmVudE5hbWVzRm9yRW1pc3Npb24oZXZlbnROYW1lKSB7XG4gICAgY29uc3QgZXZlbnROYW1lcyA9IFtldmVudE5hbWVdO1xuXG4gICAgLy8gQWRkIG5hbWVzcGFjZSBwYXJlbnQgZXZlbnRzIGlmIGVuYWJsZWRcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZU5hbWVzcGFjZXMgJiYgZXZlbnROYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gZXZlbnROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAvLyDmnIDpganljJY6IOS4gOW6puOBq+WFqOmDqOOCkuioiOeul+OBm+OBmuW+kOOAheOBq+imquWQjeWJjeepuumWk+OCkuani+eviVxuICAgICAgbGV0IHBhcmVudE5hbWUgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHBhcmVudE5hbWUgPSBwYXJlbnROYW1lID8gYCR7cGFyZW50TmFtZX0uJHtwYXJ0c1tpXX1gIDogcGFydHNbaV07XG4gICAgICAgIGV2ZW50TmFtZXMucHVzaChwYXJlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmnIDpganljJY6IOODr+OCpOODq+ODieOCq+ODvOODieOBjOacieWKueOBquWgtOWQiOOBr+OAgeW/heimgeOBquODquOCueODiuODvOOBruOBv+ODnuODg+ODgeODs+OCsOOBmeOCi1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlV2lsZGNhcmRzKSB7XG4gICAgICAvLyDmnIDpganljJY6IOODquOCueODiuODvOOBruaVsOOBjOWkmuOBmeOBjuOCi+WgtOWQiOOBr+WItumZkOOBmeOCi1xuICAgICAgY29uc3QgbWF4TGlzdGVuZXJzVG9DaGVjayA9IDEwMDtcbiAgICAgIGxldCBjaGVja2VkQ291bnQgPSAwO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5saXN0ZW5lcnMua2V5cygpKSB7XG4gICAgICAgIC8vIOODr+OCpOODq+ODieOCq+ODvOODieaWh+Wtl+OCkuWQq+OCgOWgtOWQiOOBruOBv+ODgeOCp+ODg+OCr1xuICAgICAgICBpZiAoIW5hbWUuaW5jbHVkZXMoJyonKSkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICAvLyDlh6bnkIbmuIjjgb/jga7jgqTjg5njg7Pjg4jlkI3jga/jgrnjgq3jg4Pjg5dcbiAgICAgICAgaWYgKGV2ZW50TmFtZXMuaW5jbHVkZXMobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgLy8g5pyA5aSn5Yi26ZmQ44Gr6YGU44GX44Gf44KJ5YGc5q2iXG4gICAgICAgIGlmICgrK2NoZWNrZWRDb3VudCA+IG1heExpc3RlbmVyc1RvQ2hlY2spIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8g44Ov44Kk44Or44OJ44Kr44O844OJ44OR44K/44O844Oz44Gu57Ch5piT44OB44Kn44OD44KvXG4gICAgICAgIGlmICh0aGlzLl9tYXRjaGVzV2lsZGNhcmQobmFtZSwgZXZlbnROYW1lKSkge1xuICAgICAgICAgIGV2ZW50TmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudE5hbWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgd2lsZGNhcmQgcGF0dGVybiBtYXRjaGVzIGFuIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gLSBUaGUgd2lsZGNhcmQgcGF0dGVybiB0byBjaGVja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIGV2ZW50IG5hbWUgdG8gbWF0Y2ggYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHBhdHRlcm4gbWF0Y2hlcyB0aGUgZXZlbnQgbmFtZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hdGNoZXNXaWxkY2FyZChwYXR0ZXJuLCBldmVudE5hbWUpIHtcbiAgICAvLyDjg5Hjgr/jg7zjg7PjgoTlkI3liY3jgYznlbDluLjjgavplbfjgYTloLTlkIjjga/jg57jg4Pjg4Hjg7PjgrDjgpLoq6bjgoHjgovvvIjlronlhajlr77nrZbvvIlcbiAgICBpZiAocGF0dGVybi5sZW5ndGggPiAxMDAwIHx8IGV2ZW50TmFtZS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8g5Y2Y57SU44Gq44OB44Kn44OD44KvXG4gICAgaWYgKHBhdHRlcm4gPT09IGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8g5Y2Y57SU44Gq44Ov44Kk44Or44OJ44Kr44O844OJ44OB44Kn44OD44KvXG4gICAgaWYgKHBhdHRlcm4gPT09ICcqJykge1xuICAgICAgcmV0dXJuICFldmVudE5hbWUuaW5jbHVkZXMoJy4nKTtcbiAgICB9XG5cbiAgICBpZiAocGF0dGVybiA9PT0gJyoqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8g6KSH5pWw6ZqO5bGk44Gu44Ov44Kk44Or44OJ44Kr44O844OJICgqKikg44Gu5Yem55CGXG4gICAgaWYgKHBhdHRlcm4uaW5jbHVkZXMoJyoqJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gcGF0dGVybi5zcGxpdCgnKionKTtcbiAgICAgIFxuICAgICAgLy8g5pyA6YGp5YyWOiDmnIDlpKcy44Gk44Gu44OR44O844OI44Gu44G/44KS44K144Od44O844OIXG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIOODkeOCv+ODvOODs+OBjCAnZ2FtZS4qKicg44Gu44KI44GG44Gq5b2i5byP44Gu5aC05ZCIXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyICYmIHBhcnRzWzFdID09PSAnJykge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLnN0YXJ0c1dpdGgocGFydHNbMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyDjg5Hjgr/jg7zjg7PjgYwgJyoqLmVuZCcg44Gu44KI44GG44Gq5b2i5byP44Gu5aC05ZCIXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyICYmIHBhcnRzWzBdID09PSAnJykge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLmVuZHNXaXRoKHBhcnRzWzFdKTtcbiAgICAgIH1cblxuICAgICAgLy8g44OR44K/44O844Oz44GMICdzdGFydC4qKi5lbmQnIOOBruOCiOOBhuOBquW9ouW8j+OBruWgtOWQiFxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLnN0YXJ0c1dpdGgocGFydHNbMF0pICYmIGV2ZW50TmFtZS5lbmRzV2l0aChwYXJ0c1sxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g5Y2Y5LiA6ZqO5bGk44Gu44Ov44Kk44Or44OJ44Kr44O844OJICgqKSDjga7lh6bnkIZcbiAgICBpZiAocGF0dGVybi5pbmNsdWRlcygnKicpICYmICFwYXR0ZXJuLmluY2x1ZGVzKCcqKicpKSB7XG4gICAgICAvLyDmraPopo/ooajnj77jgpLkvb/jgo/jgarjgYTmnIDpganljJbjgZXjgozjgZ/mlrnms5VcbiAgICAgIGNvbnN0IHBhdHRlcm5QYXJ0cyA9IHBhdHRlcm4uc3BsaXQoJy4nKTtcbiAgICAgIGNvbnN0IGV2ZW50UGFydHMgPSBldmVudE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIFxuICAgICAgaWYgKHBhdHRlcm5QYXJ0cy5sZW5ndGggIT09IGV2ZW50UGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdHRlcm5QYXJ0c1tpXSA9PT0gJyonKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIOODr+OCpOODq+ODieOCq+ODvOODieOBr+S9leOBq+OCguODnuODg+ODgeOBmeOCi1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuUGFydHNbaV0gIT09IGV2ZW50UGFydHNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U3lzdGVtOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLFdBQVcsQ0FBQztFQUNoQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLFdBQVdBLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtJQUN4QjtJQUNBLElBQUksQ0FBQ0EsT0FBTyxHQUFHO01BQ2JDLGdCQUFnQixFQUFFLElBQUk7TUFDdEJDLFNBQVMsRUFBRSxLQUFLO01BQ2hCQyxlQUFlLEVBQUUsS0FBSztNQUN0QkMsWUFBWSxFQUFFLEdBQUc7TUFDakIsR0FBR0o7SUFDTCxDQUFDOztJQUVEO0lBQ0EsSUFBSSxDQUFDSyxTQUFTLEdBQUcsSUFBSUMsR0FBRyxDQUFDLENBQUM7O0lBRTFCO0lBQ0EsSUFBSSxDQUFDQyxZQUFZLEdBQUcsRUFBRTs7SUFFdEI7SUFDQSxJQUFJLENBQUNDLFNBQVMsR0FBRyxLQUFLOztJQUV0QjtJQUNBLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsRUFBRTtJQUMzQixJQUFJLENBQUNDLGdC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