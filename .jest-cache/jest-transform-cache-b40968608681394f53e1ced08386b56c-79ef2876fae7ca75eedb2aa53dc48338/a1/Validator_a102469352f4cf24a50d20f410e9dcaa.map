{"version":3,"names":["ErrorCatalog","require","Validator","constructor","errorHandler","customValidators","Map","validateExists","value","errorCode","customMessage","context","undefined","error","createError","handleError","validateCondition","condition","validateType","expectedType","valid","Array","isArray","some","type","_checkType","typeName","join","actualType","toLowerCase","isNaN","Number","isInteger","validateRange","min","max","validateEnum","allowedValues","includes","validatePlayerAction","action","player","gameState","PLAYER","PLAYER_NOT_FOUND","code","actionType","playerId","actor","isAlive","DEAD_PLAYER_ACTION","id","currentPhase","allowedInPhase","_isActionAllowedInPhase","ACTION","ACTION_PHASE_MISMATCH","target","targetPlayer","getPlayer","INVALID_ACTION_TARGET","targetId","_isSelfTargetForbidden","SELF_TARGET_FORBIDDEN","validateRoleAction","role","ROLE","ROLE_NOT_FOUND","roleName","name","canUseAbility","RESTRICTED_ABILITY","phase","turn","currentTurn","_hasConsecutiveActionRestriction","_isConsecutiveAction","CONSECUTIVE_ACTION_FORBIDDEN","validateGameState","hasStarted","PHASE","GAME_NOT_STARTED","hasEnded","GAME_ALREADY_ENDED","registerValidator","validatorFn","Error","set","executeCustomValidator","args","validator","get","phaseActionMap","selfTargetAllowed","previousActions","getActionHistory","length","lastAction","module","exports"],"sources":["Validator.js"],"sourcesContent":["/**\n * Validator - Input validation and business rule enforcement\n *\n * Provides utility methods for validating input data and enforcing game rules\n * with standardized error handling\n */\n\nconst { ErrorCatalog } = require('./ErrorCatalog');\n\n/**\n * Validator class containing methods for input and business rule validation\n */\nclass Validator {\n  /**\n   * Create a new validator\n   * @param {ErrorHandler} errorHandler - Error handler instance\n   */\n  constructor(errorHandler) {\n    this.errorHandler = errorHandler;\n    this.customValidators = new Map();\n  }\n\n  /**\n   * Validate that a value exists (not null or undefined)\n   * @param {*} value - Value to check\n   * @param {string} errorCode - Error code if validation fails\n   * @param {string} [customMessage] - Optional custom error message\n   * @param {Object} [context] - Additional context for the error\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateExists(value, errorCode, customMessage, context = {}) {\n    if (value === undefined || value === null) {\n      const error = this.errorHandler.createError(\n        errorCode,\n        customMessage,\n        context\n      );\n      return this.errorHandler.handleError(error);\n    }\n    return true;\n  }\n\n  /**\n   * Validate that a condition is true\n   * @param {boolean} condition - Condition to check\n   * @param {string} errorCode - Error code if validation fails\n   * @param {string} [customMessage] - Optional custom error message\n   * @param {Object} [context] - Additional context for the error\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateCondition(condition, errorCode, customMessage, context = {}) {\n    if (!condition) {\n      const error = this.errorHandler.createError(\n        errorCode,\n        customMessage,\n        context\n      );\n      return this.errorHandler.handleError(error);\n    }\n    return true;\n  }\n\n  /**\n   * Validate that a value is of a specific type\n   * @param {*} value - Value to check\n   * @param {string|string[]} expectedType - Expected type(s) of the value\n   * @param {string} errorCode - Error code if validation fails\n   * @param {string} [customMessage] - Optional custom error message\n   * @param {Object} [context] - Additional context for the error\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateType(value, expectedType, errorCode, customMessage, context = {}) {\n    let valid = false;\n    \n    if (Array.isArray(expectedType)) {\n      // Check against multiple possible types\n      valid = expectedType.some(type => this._checkType(value, type));\n    } else {\n      // Check against a single type\n      valid = this._checkType(value, expectedType);\n    }\n    \n    if (!valid) {\n      const typeName = Array.isArray(expectedType) \n        ? expectedType.join(' or ') \n        : expectedType;\n        \n      const error = this.errorHandler.createError(\n        errorCode,\n        customMessage || `期待される型: ${typeName}, 実際の型: ${typeof value}`,\n        { ...context, expectedType, actualType: typeof value, value }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Internal helper to check a value against a type\n   * @param {*} value - Value to check\n   * @param {string} type - Type to check against\n   * @return {boolean} - True if value matches the type\n   * @private\n   */\n  _checkType(value, type) {\n    switch (type.toLowerCase()) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number' && !isNaN(value);\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'object':\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n      case 'array':\n        return Array.isArray(value);\n      case 'function':\n        return typeof value === 'function';\n      case 'undefined':\n        return typeof value === 'undefined';\n      case 'null':\n        return value === null;\n      case 'integer':\n        return Number.isInteger(value);\n      case 'positive':\n        return typeof value === 'number' && !isNaN(value) && value > 0;\n      case 'nonnegative':\n        return typeof value === 'number' && !isNaN(value) && value >= 0;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Validate that a value is within a range\n   * @param {number} value - Value to check\n   * @param {number} min - Minimum allowed value (inclusive)\n   * @param {number} max - Maximum allowed value (inclusive)\n   * @param {string} errorCode - Error code if validation fails\n   * @param {string} [customMessage] - Optional custom error message\n   * @param {Object} [context] - Additional context for the error\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateRange(value, min, max, errorCode, customMessage, context = {}) {\n    if (typeof value !== 'number' || value < min || value > max) {\n      const error = this.errorHandler.createError(\n        errorCode,\n        customMessage || `値は${min}から${max}の範囲内である必要があります`,\n        { ...context, min, max, value }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    return true;\n  }\n\n  /**\n   * Validate that a value is one of the allowed values\n   * @param {*} value - Value to check\n   * @param {Array} allowedValues - Array of allowed values\n   * @param {string} errorCode - Error code if validation fails\n   * @param {string} [customMessage] - Optional custom error message\n   * @param {Object} [context] - Additional context for the error\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateEnum(value, allowedValues, errorCode, customMessage, context = {}) {\n    if (!allowedValues.includes(value)) {\n      const error = this.errorHandler.createError(\n        errorCode,\n        customMessage || `値は許可されたもの(${allowedValues.join(', ')})のいずれかである必要があります`,\n        { ...context, allowedValues, value }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    return true;\n  }\n\n  /**\n   * Validate player action based on game rules\n   * @param {Object} action - Action to validate\n   * @param {Object} player - Player performing the action\n   * @param {Object} gameState - Current game state\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validatePlayerAction(action, player, gameState) {\n    // Validate player exists\n    if (!this.validateExists(player, ErrorCatalog.PLAYER.PLAYER_NOT_FOUND.code, null, \n                          { actionType: action.type, playerId: action.actor })) {\n      return false;\n    }\n    \n    // Validate player is alive\n    if (!player.isAlive) {\n      const error = this.errorHandler.createError(\n        ErrorCatalog.PLAYER.DEAD_PLAYER_ACTION.code,\n        null,\n        { playerId: player.id, actionType: action.type }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    // Validate action is allowed in current phase\n    const currentPhase = gameState.currentPhase;\n    const allowedInPhase = this._isActionAllowedInPhase(action.type, currentPhase);\n    \n    if (!allowedInPhase) {\n      const error = this.errorHandler.createError(\n        ErrorCatalog.ACTION.ACTION_PHASE_MISMATCH.code,\n        null,\n        { \n          actionType: action.type, \n          currentPhase: currentPhase,\n          playerId: player.id \n        }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    // Validate target if needed\n    if (action.target !== undefined) {\n      const targetPlayer = gameState.getPlayer?.(action.target);\n      \n      if (!this.validateExists(targetPlayer, ErrorCatalog.ACTION.INVALID_ACTION_TARGET.code, null, \n                           { actionType: action.type, targetId: action.target })) {\n        return false;\n      }\n      \n      // Check for self-targeting if not allowed\n      if (action.actor === action.target && this._isSelfTargetForbidden(action.type)) {\n        const error = this.errorHandler.createError(\n          ErrorCatalog.PLAYER.SELF_TARGET_FORBIDDEN.code,\n          null,\n          { actionType: action.type, playerId: player.id }\n        );\n        return this.errorHandler.handleError(error);\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Validate role action based on role capabilities and game rules\n   * @param {Object} action - Action to validate\n   * @param {Object} role - Role performing the action\n   * @param {Object} gameState - Current game state\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateRoleAction(action, role, gameState) {\n    // Validate role exists\n    if (!this.validateExists(role, ErrorCatalog.ROLE.ROLE_NOT_FOUND.code, null, \n                         { actionType: action.type, roleName: role?.name })) {\n      return false;\n    }\n    \n    // Check if role can use this action type\n    if (!role.canUseAbility || !role.canUseAbility(action.type, gameState)) {\n      const error = this.errorHandler.createError(\n        ErrorCatalog.ROLE.RESTRICTED_ABILITY.code,\n        null,\n        { \n          roleName: role.name, \n          actionType: action.type,\n          playerId: action.actor,\n          phase: gameState.currentPhase,\n          turn: gameState.currentTurn\n        }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    // Check for consecutive action restriction (e.g. consecutive guard)\n    if (this._hasConsecutiveActionRestriction(action.type, role.name) && \n        this._isConsecutiveAction(action, gameState)) {\n      const error = this.errorHandler.createError(\n        ErrorCatalog.ACTION.CONSECUTIVE_ACTION_FORBIDDEN.code,\n        null,\n        { \n          roleName: role.name, \n          actionType: action.type,\n          targetId: action.target,\n          playerId: action.actor\n        }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    return true;\n  }\n\n  /**\n   * Validate game state for a specific action\n   * @param {Object} action - Action to validate\n   * @param {Object} gameState - Current game state\n   * @return {boolean} - True if validation passes, false otherwise\n   * @throws {Error} - If validation fails and throwOnError is true in handler\n   */\n  validateGameState(action, gameState) {\n    // Validate game has started\n    if (!gameState.hasStarted) {\n      const error = this.errorHandler.createError(\n        ErrorCatalog.PHASE.GAME_NOT_STARTED.code,\n        null,\n        { actionType: action.type }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    // Validate game has not ended\n    if (gameState.hasEnded) {\n      const error = this.errorHandler.createError(\n        ErrorCatalog.PHASE.GAME_ALREADY_ENDED.code,\n        null,\n        { actionType: action.type }\n      );\n      return this.errorHandler.handleError(error);\n    }\n    \n    return true;\n  }\n\n  /**\n   * Register a custom validator function\n   * @param {string} name - Name of the validator\n   * @param {Function} validatorFn - Validator function\n   * @return {Validator} - This instance for chaining\n   */\n  registerValidator(name, validatorFn) {\n    if (typeof validatorFn !== 'function') {\n      throw new Error('Validator must be a function');\n    }\n    this.customValidators.set(name, validatorFn);\n    return this;\n  }\n\n  /**\n   * Execute a custom validator\n   * @param {string} name - Name of the validator to execute\n   * @param {*} args - Arguments to pass to the validator\n   * @return {boolean} - Result of the validation\n   * @throws {Error} - If validator doesn't exist\n   */\n  executeCustomValidator(name, ...args) {\n    const validator = this.customValidators.get(name);\n    if (!validator) {\n      throw new Error(`Validator '${name}' not found`);\n    }\n    return validator(...args);\n  }\n\n  /**\n   * Check if an action is allowed in the current phase\n   * @param {string} actionType - Type of action\n   * @param {string} phase - Current game phase\n   * @return {boolean} - True if action is allowed in this phase\n   * @private\n   */\n  _isActionAllowedInPhase(actionType, phase) {\n    // This is a simplified implementation\n    // In a real implementation, this would check against a phase-action mapping\n    \n    // Example mapping:\n    const phaseActionMap = {\n      'night': ['fortune', 'guard', 'attack'],\n      'day': ['talk', 'accuse'],\n      'vote': ['vote'],\n      'runoffVote': ['vote']\n    };\n    \n    if (!phaseActionMap[phase]) {\n      return false;\n    }\n    \n    return phaseActionMap[phase].includes(actionType);\n  }\n\n  /**\n   * Check if self-targeting is forbidden for an action type\n   * @param {string} actionType - Type of action\n   * @return {boolean} - True if self-targeting is forbidden\n   * @private\n   */\n  _isSelfTargetForbidden(actionType) {\n    // Most actions forbid self-targeting\n    const selfTargetAllowed = ['talk', 'protect'];\n    return !selfTargetAllowed.includes(actionType);\n  }\n\n  /**\n   * Check if an action type has consecutive use restrictions\n   * @param {string} actionType - Type of action\n   * @param {string} roleName - Name of the role\n   * @return {boolean} - True if consecutive use is restricted\n   * @private\n   */\n  _hasConsecutiveActionRestriction(actionType, roleName) {\n    // For now, only guard action by knight has this restriction\n    return actionType === 'guard' && roleName === 'knight';\n  }\n\n  /**\n   * Check if an action is a consecutive action (same target as last time)\n   * @param {Object} action - Current action\n   * @param {Object} gameState - Current game state\n   * @return {boolean} - True if this is a consecutive action\n   * @private\n   */\n  _isConsecutiveAction(action, gameState) {\n    // This is a simplified implementation\n    // In a real implementation, this would check the action history\n    \n    const previousActions = gameState.getActionHistory?.(action.actor, action.type) || [];\n    if (previousActions.length === 0) {\n      return false;\n    }\n    \n    const lastAction = previousActions[previousActions.length - 1];\n    return lastAction.target === action.target;\n  }\n}\n\nmodule.exports = Validator;\n"],"mappings":"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","ignoreList":[]}