c1e15f7c0b2d6d799235c30a1b938835
/**
 * EventSystem - Core event management module for the werewolf game GM support library
 *
 * This module provides the foundation for the event-driven architecture,
 * enabling communication between different modules through events.
 */

class EventSystem {
  /**
   * Creates a new EventSystem instance
   * @param {Object} options - Configuration options
   * @param {boolean} [options.enableNamespaces=true] - Enable hierarchical event namespaces
   * @param {boolean} [options.debugMode=false] - Enable debug mode with event history
   * @param {boolean} [options.enableWildcards=false] - Enable wildcard event matching
   * @param {number} [options.historyLimit=100] - Maximum number of events to keep in history
   */
  constructor(options = {}) {
    // Default options
    this.options = {
      enableNamespaces: true,
      debugMode: false,
      enableWildcards: false,
      historyLimit: 100,
      ...options
    };

    // Map to store event listeners: { eventName => [{ callback, once, priority }] }
    this.listeners = new Map();

    // Event history for debugging (only active in debug mode)
    this.eventHistory = [];

    // Flag to track if we're currently emitting an event (to handle nested emissions)
    this._emitting = false;

    // Queue for listeners to be added/removed during emission
    this._pendingAdditions = [];
    this._pendingRemovals = [];
  }

  /**
   * Register an event listener
   * @param {string} eventName - Name of the event to listen for
   * @param {Function} callback - Function to call when the event is emitted
   * @param {number} [priority=0] - Priority of the listener (higher executes first)
   * @return {EventSystem} - Returns this instance for chaining
   * @throws {Error} If eventName is not a string or callback is not a function
   */
  on(eventName, callback, priority = 0) {
    // Validate arguments
    if (typeof eventName !== 'string' || eventName.trim() === '') {
      throw new Error('Event name must be a non-empty string');
    }
    if (typeof callback !== 'function') {
      throw new Error('Callback must be a function');
    }

    // If we're currently emitting, queue the addition
    if (this._emitting) {
      this._pendingAdditions.push({
        eventName,
        callback,
        priority,
        once: false
      });
      return this;
    }

    // Get or create the listeners array for this event
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, []);
    }
    const listeners = this.listeners.get(eventName);

    // Check for duplicate listener
    const existingIndex = listeners.findIndex(listener => listener.callback === callback);
    if (existingIndex !== -1) {
      // Update the existing listener's priority
      listeners[existingIndex].priority = priority;
    } else {
      // Add the new listener
      listeners.push({
        callback,
        once: false,
        priority
      });

      // Sort listeners by priority (highest first)
      listeners.sort((a, b) => b.priority - a.priority);
    }
    return this;
  }

  /**
   * Register a one-time event listener that will be removed after execution
   * @param {string} eventName - Name of the event to listen for
   * @param {Function} callback - Function to call when the event is emitted
   * @param {number} [priority=0] - Priority of the listener (higher executes first)
   * @return {EventSystem} - Returns this instance for chaining
   * @throws {Error} If eventName is not a string or callback is not a function
   */
  once(eventName, callback, priority = 0) {
    // Validate arguments
    if (typeof eventName !== 'string' || eventName.trim() === '') {
      throw new Error('Event name must be a non-empty string');
    }
    if (typeof callback !== 'function') {
      throw new Error('Callback must be a function');
    }

    // If we're currently emitting, queue the addition
    if (this._emitting) {
      this._pendingAdditions.push({
        eventName,
        callback,
        priority,
        once: true
      });
      return this;
    }

    // Get or create the listeners array for this event
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, []);
    }
    const listeners = this.listeners.get(eventName);

    // Check for duplicate listener
    const existingIndex = listeners.findIndex(listener => listener.callback === callback);
    if (existingIndex !== -1) {
      // Update the existing listener's priority and once flag
      listeners[existingIndex].priority = priority;
      listeners[existingIndex].once = true;
    } else {
      // Add the new listener
      listeners.push({
        callback,
        once: true,
        priority
      });

      // Sort listeners by priority (highest first)
      listeners.sort((a, b) => b.priority - a.priority);
    }
    return this;
  }

  /**
   * Remove an event listener
   * @param {string} eventName - Name of the event to remove listener from
   * @param {Function} [callback] - Specific callback to remove (if omitted, all listeners for the event are removed)
   * @return {EventSystem} - Returns this instance for chaining
   */
  off(eventName, callback = null) {
    // If we're currently emitting, queue the removal
    if (this._emitting) {
      this._pendingRemovals.push({
        eventName,
        callback
      });
      return this;
    }

    // If eventName doesn't exist, nothing to do
    if (!this.listeners.has(eventName)) {
      return this;
    }

    // If callback is null, remove all listeners for this event
    if (callback === null) {
      this.listeners.delete(eventName);
      return this;
    }

    // Otherwise, only remove the specific callback
    const listeners = this.listeners.get(eventName);
    const filteredListeners = listeners.filter(listener => listener.callback !== callback);
    if (filteredListeners.length === 0) {
      // If no listeners remain, remove the event entirely
      this.listeners.delete(eventName);
    } else {
      // Otherwise, update the listeners array
      this.listeners.set(eventName, filteredListeners);
    }
    return this;
  }

  /**
   * Emit an event to all registered listeners
   * @param {string} eventName - Name of the event to emit
   * @param {*} [data] - Data to pass to the listeners
   * @return {boolean} - True if the event had listeners, false otherwise
   */
  emit(eventName, data) {
    // Mark that we're emitting an event
    const wasEmitting = this._emitting;
    this._emitting = true;

    // Track whether any listeners were called
    let listenersCalled = false;
    try {
      // Add to history if debug mode is enabled
      if (this.options.debugMode) {
        this._addToHistory(eventName, data);
      }

      // Get all event names to emit based on the options
      const eventNamesToEmit = this._getEventNamesForEmission(eventName);

      // Emit to each matched event name
      for (const name of eventNamesToEmit) {
        if (this.listeners.has(name)) {
          const listeners = this.listeners.get(name);
          const listenersToRemove = [];

          // Call each listener
          for (let i = 0; i < listeners.length; i++) {
            const {
              callback,
              once
            } = listeners[i];
            try {
              // Call the listener with the event data
              callback(data);
              listenersCalled = true;

              // If it's a once listener, mark it for removal
              if (once) {
                listenersToRemove.push(callback);
              }
            } catch (error) {
              // Log the error but continue with other listeners
              console.error(`Error in event listener for '${name}':`, error);
            }
          }

          // Remove once listeners (if we're not in a nested emit)
          if (!wasEmitting) {
            for (const callback of listenersToRemove) {
              this.off(name, callback);
            }
          }
        }
      }

      // Process pending additions and removals (if we're not in a nested emit)
      if (!wasEmitting) {
        this._processPendingOperations();
      }
      return listenersCalled;
    } finally {
      // Only reset the emitting flag if we're the outermost emit call
      if (!wasEmitting) {
        this._emitting = false;
      }
    }
  }

  /**
   * Check if an event has any listeners
   * @param {string} eventName - Name of the event to check
   * @return {boolean} - True if the event has listeners, false otherwise
   */
  hasListeners(eventName) {
    // Direct match
    if (this.listeners.has(eventName) && this.listeners.get(eventName).length > 0) {
      return true;
    }

    // If wildcards are enabled, check for wildcard matches
    if (this.options.enableWildcards) {
      for (const [name, listeners] of this.listeners.entries()) {
        if (listeners.length > 0 && this._matchesWildcard(name, eventName)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get the number of listeners for an event
   * @param {string} eventName - Name of the event to check
   * @return {number} - Number of listeners for the event
   */
  listenerCount(eventName) {
    let count = 0;

    // Direct match
    if (this.listeners.has(eventName)) {
      count += this.listeners.get(eventName).length;
    }

    // If wildcards are enabled, check for wildcard matches
    if (this.options.enableWildcards) {
      for (const [name, listeners] of this.listeners.entries()) {
        if (name !== eventName && this._matchesWildcard(name, eventName)) {
          count += listeners.length;
        }
      }
    }
    return count;
  }

  /**
   * Get all registered event names
   * @return {string[]} - Array of registered event names
   */
  eventNames() {
    return Array.from(this.listeners.keys());
  }

  /**
   * Get the recent event history (only available in debug mode)
   * @param {number} [limit=10] - Maximum number of events to return
   * @return {Array} - Array of recent events or empty array if debug mode is disabled
   */
  getEventHistory(limit = 10) {
    if (!this.options.debugMode) {
      return [];
    }
    const actualLimit = Math.min(limit, this.eventHistory.length);
    return this.eventHistory.slice(-actualLimit);
  }

  /**
   * Clear all event listeners
   * @return {EventSystem} - Returns this instance for chaining
   */
  removeAllListeners() {
    this.listeners.clear();
    return this;
  }

  /**
   * Process pending listener additions and removals
   * @private
   */
  _processPendingOperations() {
    // Process removals first to avoid issues with additions that would be immediately removed
    for (const {
      eventName,
      callback
    } of this._pendingRemovals) {
      this.off(eventName, callback);
    }
    this._pendingRemovals = [];

    // Then process additions
    for (const {
      eventName,
      callback,
      priority,
      once
    } of this._pendingAdditions) {
      if (once) {
        this.once(eventName, callback, priority);
      } else {
        this.on(eventName, callback, priority);
      }
    }
    this._pendingAdditions = [];
  }

  /**
   * Add an event to the history
   * @param {string} eventName - Name of the emitted event
   * @param {*} data - Data passed with the event
   * @private
   */
  _addToHistory(eventName, data) {
    // Add to history with timestamp
    this.eventHistory.push({
      eventName,
      data,
      timestamp: new Date()
    });

    // Trim history if it exceeds the limit
    if (this.eventHistory.length > this.options.historyLimit) {
      this.eventHistory.shift();
    }
  }

  /**
   * Get all event names to emit based on the original event and options
   * @param {string} eventName - The original event name
   * @return {string[]} - Array of event names to emit
   * @private
   */
  _getEventNamesForEmission(eventName) {
    const eventNames = [eventName];

    // Add namespace parent events if enabled
    if (this.options.enableNamespaces && eventName.includes('.')) {
      const parts = eventName.split('.');
      for (let i = parts.length - 1; i > 0; i--) {
        eventNames.push(parts.slice(0, i).join('.'));
      }
    }

    // Add wildcard matches if enabled
    if (this.options.enableWildcards) {
      for (const name of this.listeners.keys()) {
        if (!eventNames.includes(name) && this._matchesWildcard(name, eventName)) {
          eventNames.push(name);
        }
      }
    }
    return eventNames;
  }

  /**
   * Check if a wildcard pattern matches an event name
   * @param {string} pattern - The wildcard pattern to check
   * @param {string} eventName - The event name to match against
   * @return {boolean} - True if the pattern matches the event name
   * @private
   */
  _matchesWildcard(pattern, eventName) {
    // パターンや名前が異常に長い場合はマッチングを諦める（安全対策）
    if (pattern.length > 1000 || eventName.length > 1000) {
      console.warn('Excessively long pattern or event name, skipping wildcard match for safety');
      return false;
    }

    // 単純なチェック
    if (pattern === eventName) {
      return true;
    }

    // 単純なワイルドカードチェック
    if (pattern === '*') {
      return !eventName.includes('.');
    }
    if (pattern === '**') {
      return true;
    }

    // 複数階層のワイルドカード (**) の処理
    if (pattern.includes('**')) {
      const parts = pattern.split('**');

      // パターンが 'game.**' のような形式の場合
      if (parts.length === 2 && parts[1] === '') {
        return eventName.startsWith(parts[0]);
      }

      // パターンが '**.end' のような形式の場合
      if (parts.length === 2 && parts[0] === '') {
        return eventName.endsWith(parts[1]);
      }

      // パターンが 'start.**.end' のような形式の場合
      if (parts.length === 2) {
        return eventName.startsWith(parts[0]) && eventName.endsWith(parts[1]);
      }
    }

    // 単一階層のワイルドカード (*) の処理
    if (pattern.includes('*') && !pattern.includes('**')) {
      try {
        const regexPattern = '^' + pattern.replace(/\./g, '\\.').replace(/\*/g, '[^.]+') + '$';
        const regex = new RegExp(regexPattern);
        return regex.test(eventName);
      } catch (e) {
        console.error('Invalid regex pattern:', pattern);
        return false;
      }
    }
    return false;
  }
}
module.exports = EventSystem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFdmVudFN5c3RlbSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImVuYWJsZU5hbWVzcGFjZXMiLCJkZWJ1Z01vZGUiLCJlbmFibGVXaWxkY2FyZHMiLCJoaXN0b3J5TGltaXQiLCJsaXN0ZW5lcnMiLCJNYXAiLCJldmVudEhpc3RvcnkiLCJfZW1pdHRpbmciLCJfcGVuZGluZ0FkZGl0aW9ucyIsIl9wZW5kaW5nUmVtb3ZhbHMiLCJvbiIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwicHJpb3JpdHkiLCJ0cmltIiwiRXJyb3IiLCJwdXNoIiwib25jZSIsImhhcyIsInNldCIsImdldCIsImV4aXN0aW5nSW5kZXgiLCJmaW5kSW5kZXgiLCJsaXN0ZW5lciIsInNvcnQiLCJhIiwiYiIsIm9mZiIsImRlbGV0ZSIsImZpbHRlcmVkTGlzdGVuZXJzIiwiZmlsdGVyIiwibGVuZ3RoIiwiZW1pdCIsImRhdGEiLCJ3YXNFbWl0dGluZyIsImxpc3RlbmVyc0NhbGxlZCIsIl9hZGRUb0hpc3RvcnkiLCJldmVudE5hbWVzVG9FbWl0IiwiX2dldEV2ZW50TmFtZXNGb3JFbWlzc2lvbiIsIm5hbWUiLCJsaXN0ZW5lcnNUb1JlbW92ZSIsImkiLCJlcnJvciIsImNvbnNvbGUiLCJfcHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zIiwiaGFzTGlzdGVuZXJzIiwiZW50cmllcyIsIl9tYXRjaGVzV2lsZGNhcmQiLCJsaXN0ZW5lckNvdW50IiwiY291bnQiLCJldmVudE5hbWVzIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsImdldEV2ZW50SGlzdG9yeSIsImxpbWl0IiwiYWN0dWFsTGltaXQiLCJNYXRoIiwibWluIiwic2xpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjbGVhciIsInRpbWVzdGFtcCIsIkRhdGUiLCJzaGlmdCIsImluY2x1ZGVzIiwicGFydHMiLCJzcGxpdCIsImpvaW4iLCJwYXR0ZXJuIiwid2FybiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInJlZ2V4UGF0dGVybiIsInJlcGxhY2UiLCJyZWdleCIsIlJlZ0V4cCIsInRlc3QiLCJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIkV2ZW50U3lzdGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXZlbnRTeXN0ZW0gLSBDb3JlIGV2ZW50IG1hbmFnZW1lbnQgbW9kdWxlIGZvciB0aGUgd2VyZXdvbGYgZ2FtZSBHTSBzdXBwb3J0IGxpYnJhcnlcbiAqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB0aGUgZm91bmRhdGlvbiBmb3IgdGhlIGV2ZW50LWRyaXZlbiBhcmNoaXRlY3R1cmUsXG4gKiBlbmFibGluZyBjb21tdW5pY2F0aW9uIGJldHdlZW4gZGlmZmVyZW50IG1vZHVsZXMgdGhyb3VnaCBldmVudHMuXG4gKi9cblxuY2xhc3MgRXZlbnRTeXN0ZW0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFdmVudFN5c3RlbSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZU5hbWVzcGFjZXM9dHJ1ZV0gLSBFbmFibGUgaGllcmFyY2hpY2FsIGV2ZW50IG5hbWVzcGFjZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWJ1Z01vZGU9ZmFsc2VdIC0gRW5hYmxlIGRlYnVnIG1vZGUgd2l0aCBldmVudCBoaXN0b3J5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlV2lsZGNhcmRzPWZhbHNlXSAtIEVuYWJsZSB3aWxkY2FyZCBldmVudCBtYXRjaGluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGlzdG9yeUxpbWl0PTEwMF0gLSBNYXhpbXVtIG51bWJlciBvZiBldmVudHMgdG8ga2VlcCBpbiBoaXN0b3J5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVOYW1lc3BhY2VzOiB0cnVlLFxuICAgICAgZGVidWdNb2RlOiBmYWxzZSxcbiAgICAgIGVuYWJsZVdpbGRjYXJkczogZmFsc2UsXG4gICAgICBoaXN0b3J5TGltaXQ6IDEwMCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gTWFwIHRvIHN0b3JlIGV2ZW50IGxpc3RlbmVyczogeyBldmVudE5hbWUgPT4gW3sgY2FsbGJhY2ssIG9uY2UsIHByaW9yaXR5IH1dIH1cbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIEV2ZW50IGhpc3RvcnkgZm9yIGRlYnVnZ2luZyAob25seSBhY3RpdmUgaW4gZGVidWcgbW9kZSlcbiAgICB0aGlzLmV2ZW50SGlzdG9yeSA9IFtdO1xuXG4gICAgLy8gRmxhZyB0byB0cmFjayBpZiB3ZSdyZSBjdXJyZW50bHkgZW1pdHRpbmcgYW4gZXZlbnQgKHRvIGhhbmRsZSBuZXN0ZWQgZW1pc3Npb25zKVxuICAgIHRoaXMuX2VtaXR0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBRdWV1ZSBmb3IgbGlzdGVuZXJzIHRvIGJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIGVtaXNzaW9uXG4gICAgdGhpcy5fcGVuZGluZ0FkZGl0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFscyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MF0gLSBQcmlvcml0eSBvZiB0aGUgbGlzdGVuZXIgKGhpZ2hlciBleGVjdXRlcyBmaXJzdClcbiAgICogQHJldHVybiB7RXZlbnRTeXN0ZW19IC0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgZXZlbnROYW1lIGlzIG5vdCBhIHN0cmluZyBvciBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblxuICAgKi9cbiAgb24oZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHkgPSAwKSB7XG4gICAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgIT09ICdzdHJpbmcnIHx8IGV2ZW50TmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBlbWl0dGluZywgcXVldWUgdGhlIGFkZGl0aW9uXG4gICAgaWYgKHRoaXMuX2VtaXR0aW5nKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nQWRkaXRpb25zLnB1c2goeyBldmVudE5hbWUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZTogZmFsc2UgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoaXMgZXZlbnRcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG5cbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGxpc3RlbmVyXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgobGlzdGVuZXIgPT4gbGlzdGVuZXIuY2FsbGJhY2sgPT09IGNhbGxiYWNrKTtcbiAgICBpZiAoZXhpc3RpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgbGlzdGVuZXIncyBwcmlvcml0eVxuICAgICAgbGlzdGVuZXJzW2V4aXN0aW5nSW5kZXhdLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCB0aGUgbmV3IGxpc3RlbmVyXG4gICAgICBsaXN0ZW5lcnMucHVzaCh7IGNhbGxiYWNrLCBvbmNlOiBmYWxzZSwgcHJpb3JpdHkgfSk7XG5cbiAgICAgIC8vIFNvcnQgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IChoaWdoZXN0IGZpcnN0KVxuICAgICAgbGlzdGVuZXJzLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG9uZS10aW1lIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGV4ZWN1dGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTBdIC0gUHJpb3JpdHkgb2YgdGhlIGxpc3RlbmVyIChoaWdoZXIgZXhlY3V0ZXMgZmlyc3QpXG4gICAqIEByZXR1cm4ge0V2ZW50U3lzdGVtfSAtIFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGV2ZW50TmFtZSBpcyBub3QgYSBzdHJpbmcgb3IgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cbiAgICovXG4gIG9uY2UoZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHkgPSAwKSB7XG4gICAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgIT09ICdzdHJpbmcnIHx8IGV2ZW50TmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBlbWl0dGluZywgcXVldWUgdGhlIGFkZGl0aW9uXG4gICAgaWYgKHRoaXMuX2VtaXR0aW5nKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nQWRkaXRpb25zLnB1c2goeyBldmVudE5hbWUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEdldCBvciBjcmVhdGUgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhpcyBldmVudFxuICAgIGlmICghdGhpcy5saXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNldChldmVudE5hbWUsIFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcblxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgbGlzdGVuZXJcbiAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gbGlzdGVuZXJzLmZpbmRJbmRleChsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2spO1xuICAgIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBsaXN0ZW5lcidzIHByaW9yaXR5IGFuZCBvbmNlIGZsYWdcbiAgICAgIGxpc3RlbmVyc1tleGlzdGluZ0luZGV4XS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgbGlzdGVuZXJzW2V4aXN0aW5nSW5kZXhdLm9uY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgdGhlIG5ldyBsaXN0ZW5lclxuICAgICAgbGlzdGVuZXJzLnB1c2goeyBjYWxsYmFjaywgb25jZTogdHJ1ZSwgcHJpb3JpdHkgfSk7XG5cbiAgICAgIC8vIFNvcnQgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IChoaWdoZXN0IGZpcnN0KVxuICAgICAgbGlzdGVuZXJzLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBsaXN0ZW5lciBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBTcGVjaWZpYyBjYWxsYmFjayB0byByZW1vdmUgKGlmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCBhcmUgcmVtb3ZlZClcbiAgICogQHJldHVybiB7RXZlbnRTeXN0ZW19IC0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgb2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGVtaXR0aW5nLCBxdWV1ZSB0aGUgcmVtb3ZhbFxuICAgIGlmICh0aGlzLl9lbWl0dGluZykge1xuICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWxzLnB1c2goeyBldmVudE5hbWUsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gSWYgZXZlbnROYW1lIGRvZXNuJ3QgZXhpc3QsIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJZiBjYWxsYmFjayBpcyBudWxsLCByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhpcyBldmVudFxuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIG9ubHkgcmVtb3ZlIHRoZSBzcGVjaWZpYyBjYWxsYmFja1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgIGNvbnN0IGZpbHRlcmVkTGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYWxsYmFjayAhPT0gY2FsbGJhY2spO1xuXG4gICAgaWYgKGZpbHRlcmVkTGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgbm8gbGlzdGVuZXJzIHJlbWFpbiwgcmVtb3ZlIHRoZSBldmVudCBlbnRpcmVseVxuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXBkYXRlIHRoZSBsaXN0ZW5lcnMgYXJyYXlcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNldChldmVudE5hbWUsIGZpbHRlcmVkTGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSAtIERhdGEgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBlbWl0KGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIC8vIE1hcmsgdGhhdCB3ZSdyZSBlbWl0dGluZyBhbiBldmVudFxuICAgIGNvbnN0IHdhc0VtaXR0aW5nID0gdGhpcy5fZW1pdHRpbmc7XG4gICAgdGhpcy5fZW1pdHRpbmcgPSB0cnVlO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkXG4gICAgbGV0IGxpc3RlbmVyc0NhbGxlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkZCB0byBoaXN0b3J5IGlmIGRlYnVnIG1vZGUgaXMgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgdGhpcy5fYWRkVG9IaXN0b3J5KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBhbGwgZXZlbnQgbmFtZXMgdG8gZW1pdCBiYXNlZCBvbiB0aGUgb3B0aW9uc1xuICAgICAgY29uc3QgZXZlbnROYW1lc1RvRW1pdCA9IHRoaXMuX2dldEV2ZW50TmFtZXNGb3JFbWlzc2lvbihldmVudE5hbWUpO1xuXG4gICAgICAvLyBFbWl0IHRvIGVhY2ggbWF0Y2hlZCBldmVudCBuYW1lXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZXZlbnROYW1lc1RvRW1pdCkge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZ2V0KG5hbWUpO1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc1RvUmVtb3ZlID0gW107XG5cbiAgICAgICAgICAvLyBDYWxsIGVhY2ggbGlzdGVuZXJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgb25jZSB9ID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBsaXN0ZW5lciB3aXRoIHRoZSBldmVudCBkYXRhXG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICBsaXN0ZW5lcnNDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBvbmNlIGxpc3RlbmVyLCBtYXJrIGl0IGZvciByZW1vdmFsXG4gICAgICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzVG9SZW1vdmUucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIExvZyB0aGUgZXJyb3IgYnV0IGNvbnRpbnVlIHdpdGggb3RoZXIgbGlzdGVuZXJzXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGV2ZW50IGxpc3RlbmVyIGZvciAnJHtuYW1lfSc6YCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbW92ZSBvbmNlIGxpc3RlbmVycyAoaWYgd2UncmUgbm90IGluIGEgbmVzdGVkIGVtaXQpXG4gICAgICAgICAgaWYgKCF3YXNFbWl0dGluZykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBsaXN0ZW5lcnNUb1JlbW92ZSkge1xuICAgICAgICAgICAgICB0aGlzLm9mZihuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3MgcGVuZGluZyBhZGRpdGlvbnMgYW5kIHJlbW92YWxzIChpZiB3ZSdyZSBub3QgaW4gYSBuZXN0ZWQgZW1pdClcbiAgICAgIGlmICghd2FzRW1pdHRpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0ZW5lcnNDYWxsZWQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIGVtaXR0aW5nIGZsYWcgaWYgd2UncmUgdGhlIG91dGVybW9zdCBlbWl0IGNhbGxcbiAgICAgIGlmICghd2FzRW1pdHRpbmcpIHtcbiAgICAgICAgdGhpcy5fZW1pdHRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gZXZlbnQgaGFzIGFueSBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZXZlbnQgaGFzIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBoYXNMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgLy8gRGlyZWN0IG1hdGNoXG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpICYmIHRoaXMubGlzdGVuZXJzLmdldChldmVudE5hbWUpLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIElmIHdpbGRjYXJkcyBhcmUgZW5hYmxlZCwgY2hlY2sgZm9yIHdpbGRjYXJkIG1hdGNoZXNcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZVdpbGRjYXJkcykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgbGlzdGVuZXJzXSBvZiB0aGlzLmxpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwICYmIHRoaXMuX21hdGNoZXNXaWxkY2FyZChuYW1lLCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciBhbiBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gY2hlY2tcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIE51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudFxuICAgKi9cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgLy8gRGlyZWN0IG1hdGNoXG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICBjb3VudCArPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnROYW1lKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSWYgd2lsZGNhcmRzIGFyZSBlbmFibGVkLCBjaGVjayBmb3Igd2lsZGNhcmQgbWF0Y2hlc1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlV2lsZGNhcmRzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCBsaXN0ZW5lcnNdIG9mIHRoaXMubGlzdGVuZXJzLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gZXZlbnROYW1lICYmIHRoaXMuX21hdGNoZXNXaWxkY2FyZChuYW1lLCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgY291bnQgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbmFtZXNcbiAgICogQHJldHVybiB7c3RyaW5nW119IC0gQXJyYXkgb2YgcmVnaXN0ZXJlZCBldmVudCBuYW1lc1xuICAgKi9cbiAgZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycy5rZXlzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVjZW50IGV2ZW50IGhpc3RvcnkgKG9ubHkgYXZhaWxhYmxlIGluIGRlYnVnIG1vZGUpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXQ9MTBdIC0gTWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHRvIHJldHVyblxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBBcnJheSBvZiByZWNlbnQgZXZlbnRzIG9yIGVtcHR5IGFycmF5IGlmIGRlYnVnIG1vZGUgaXMgZGlzYWJsZWRcbiAgICovXG4gIGdldEV2ZW50SGlzdG9yeShsaW1pdCA9IDEwKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVidWdNb2RlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWN0dWFsTGltaXQgPSBNYXRoLm1pbihsaW1pdCwgdGhpcy5ldmVudEhpc3RvcnkubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5ldmVudEhpc3Rvcnkuc2xpY2UoLWFjdHVhbExpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge0V2ZW50U3lzdGVtfSAtIFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGVuZGluZyBsaXN0ZW5lciBhZGRpdGlvbnMgYW5kIHJlbW92YWxzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCkge1xuICAgIC8vIFByb2Nlc3MgcmVtb3ZhbHMgZmlyc3QgdG8gYXZvaWQgaXNzdWVzIHdpdGggYWRkaXRpb25zIHRoYXQgd291bGQgYmUgaW1tZWRpYXRlbHkgcmVtb3ZlZFxuICAgIGZvciAoY29uc3QgeyBldmVudE5hbWUsIGNhbGxiYWNrIH0gb2YgdGhpcy5fcGVuZGluZ1JlbW92YWxzKSB7XG4gICAgICB0aGlzLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ1JlbW92YWxzID0gW107XG5cbiAgICAvLyBUaGVuIHByb2Nlc3MgYWRkaXRpb25zXG4gICAgZm9yIChjb25zdCB7IGV2ZW50TmFtZSwgY2FsbGJhY2ssIHByaW9yaXR5LCBvbmNlIH0gb2YgdGhpcy5fcGVuZGluZ0FkZGl0aW9ucykge1xuICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgdGhpcy5vbmNlKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHByaW9yaXR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBjYWxsYmFjaywgcHJpb3JpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nQWRkaXRpb25zID0gW107XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IHRvIHRoZSBoaXN0b3J5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBlbWl0dGVkIGV2ZW50XG4gICAqIEBwYXJhbSB7Kn0gZGF0YSAtIERhdGEgcGFzc2VkIHdpdGggdGhlIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkVG9IaXN0b3J5KGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIC8vIEFkZCB0byBoaXN0b3J5IHdpdGggdGltZXN0YW1wXG4gICAgdGhpcy5ldmVudEhpc3RvcnkucHVzaCh7XG4gICAgICBldmVudE5hbWUsXG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgfSk7XG5cbiAgICAvLyBUcmltIGhpc3RvcnkgaWYgaXQgZXhjZWVkcyB0aGUgbGltaXRcbiAgICBpZiAodGhpcy5ldmVudEhpc3RvcnkubGVuZ3RoID4gdGhpcy5vcHRpb25zLmhpc3RvcnlMaW1pdCkge1xuICAgICAgdGhpcy5ldmVudEhpc3Rvcnkuc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBldmVudCBuYW1lcyB0byBlbWl0IGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBldmVudCBhbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG9yaWdpbmFsIGV2ZW50IG5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nW119IC0gQXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZW1pdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEV2ZW50TmFtZXNGb3JFbWlzc2lvbihldmVudE5hbWUpIHtcbiAgICBjb25zdCBldmVudE5hbWVzID0gW2V2ZW50TmFtZV07XG5cbiAgICAvLyBBZGQgbmFtZXNwYWNlIHBhcmVudCBldmVudHMgaWYgZW5hYmxlZFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTmFtZXNwYWNlcyAmJiBldmVudE5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgY29uc3QgcGFydHMgPSBldmVudE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGV2ZW50TmFtZXMucHVzaChwYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB3aWxkY2FyZCBtYXRjaGVzIGlmIGVuYWJsZWRcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZVdpbGRjYXJkcykge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMubGlzdGVuZXJzLmtleXMoKSkge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZXMuaW5jbHVkZXMobmFtZSkgJiYgdGhpcy5fbWF0Y2hlc1dpbGRjYXJkKG5hbWUsIGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICBldmVudE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnROYW1lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHdpbGRjYXJkIHBhdHRlcm4gbWF0Y2hlcyBhbiBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIC0gVGhlIHdpbGRjYXJkIHBhdHRlcm4gdG8gY2hlY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBldmVudCBuYW1lIHRvIG1hdGNoIGFnYWluc3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBwYXR0ZXJuIG1hdGNoZXMgdGhlIGV2ZW50IG5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXRjaGVzV2lsZGNhcmQocGF0dGVybiwgZXZlbnROYW1lKSB7XG4gICAgLy8g44OR44K/44O844Oz44KE5ZCN5YmN44GM55Ww5bi444Gr6ZW344GE5aC05ZCI44Gv44Oe44OD44OB44Oz44Kw44KS6Kum44KB44KL77yI5a6J5YWo5a++562W77yJXG4gICAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gMTAwMCB8fCBldmVudE5hbWUubGVuZ3RoID4gMTAwMCkge1xuICAgICAgY29uc29sZS53YXJuKCdFeGNlc3NpdmVseSBsb25nIHBhdHRlcm4gb3IgZXZlbnQgbmFtZSwgc2tpcHBpbmcgd2lsZGNhcmQgbWF0Y2ggZm9yIHNhZmV0eScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOWNmOe0lOOBquODgeOCp+ODg+OCr1xuICAgIGlmIChwYXR0ZXJuID09PSBldmVudE5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIOWNmOe0lOOBquODr+OCpOODq+ODieOCq+ODvOODieODgeOCp+ODg+OCr1xuICAgIGlmIChwYXR0ZXJuID09PSAnKicpIHtcbiAgICAgIHJldHVybiAhZXZlbnROYW1lLmluY2x1ZGVzKCcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIOikh+aVsOmajuWxpOOBruODr+OCpOODq+ODieOCq+ODvOODiSAoKiopIOOBruWHpueQhlxuICAgIGlmIChwYXR0ZXJuLmluY2x1ZGVzKCcqKicpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHBhdHRlcm4uc3BsaXQoJyoqJyk7XG5cbiAgICAgIC8vIOODkeOCv+ODvOODs+OBjCAnZ2FtZS4qKicg44Gu44KI44GG44Gq5b2i5byP44Gu5aC05ZCIXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyICYmIHBhcnRzWzFdID09PSAnJykge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLnN0YXJ0c1dpdGgocGFydHNbMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyDjg5Hjgr/jg7zjg7PjgYwgJyoqLmVuZCcg44Gu44KI44GG44Gq5b2i5byP44Gu5aC05ZCIXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyICYmIHBhcnRzWzBdID09PSAnJykge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLmVuZHNXaXRoKHBhcnRzWzFdKTtcbiAgICAgIH1cblxuICAgICAgLy8g44OR44K/44O844Oz44GMICdzdGFydC4qKi5lbmQnIOOBruOCiOOBhuOBquW9ouW8j+OBruWgtOWQiFxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLnN0YXJ0c1dpdGgocGFydHNbMF0pICYmIGV2ZW50TmFtZS5lbmRzV2l0aChwYXJ0c1sxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g5Y2Y5LiA6ZqO5bGk44Gu44Ov44Kk44Or44OJ44Kr44O844OJICgqKSDjga7lh6bnkIZcbiAgICBpZiAocGF0dGVybi5pbmNsdWRlcygnKicpICYmICFwYXR0ZXJuLmluY2x1ZGVzKCcqKicpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWdleFBhdHRlcm4gPSAnXicgKyBwYXR0ZXJuLnJlcGxhY2UoL1xcLi9nLCAnXFxcXC4nKS5yZXBsYWNlKC9cXCovZywgJ1teLl0rJykgKyAnJCc7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFBhdHRlcm4pO1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChldmVudE5hbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHJlZ2V4IHBhdHRlcm46JywgcGF0dGVybik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFN5c3RlbTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQSxXQUFXLENBQUM7RUFDaEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFDQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDeEI7SUFDQSxJQUFJLENBQUNBLE9BQU8sR0FBRztNQUNiQyxnQkFBZ0IsRUFBRSxJQUFJO01BQ3RCQyxTQUFTLEVBQUUsS0FBSztNQUNoQkMsZUFBZSxFQUFFLEtBQUs7TUFDdEJDLFlBQVksRUFBRSxHQUFHO01BQ2pCLEdBQUdKO0lBQ0wsQ0FBQzs7SUFFRDtJQUNBLElBQUksQ0FBQ0ssU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDOztJQUUxQjtJQUNBLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7O0lBRXRCO0lBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsS0FBSzs7SUFFdEI7SUFDQSxJQUFJLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7SUFDM0IsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO0VBQzVCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsRUFBRUEsQ0FBQ0MsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsR0FBRyxDQUFDLEVBQUU7SUFDcEM7SUFDQSxJQUFJLE9BQU9GLFNBQVMsS0FBSyxRQUFRLElBQUlBLFNBQVMsQ0FBQ0csSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7TUFDNUQsTUFBTSxJQUFJQyxLQUFLLENBQUMsdUNBQXVDLENBQUM7SUFDMUQ7SUFFQSxJQUFJLE9BQU9ILFFBQVEsS0FBSyxVQUFVLEVBQUU7TUFDbEMsTUFBTSxJQUFJRyxLQUFLLENBQUMsNkJBQTZCLENBQUM7SUFDaEQ7O0lBRUE7SUFDQSxJQUFJLElBQUksQ0FBQ1IsU0FBUyxFQUFFO01BQ2xCLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNRLElBQUksQ0FBQztRQUFFTCxTQUFTO1FBQUVDLFFBQVE7UUFBRUMsUUFBUTtRQUFFSSxJQUFJLEVBQUU7TUFBTSxDQUFDLENBQUM7TUFDM0UsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7SUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDYixTQUFTLENBQUNjLEdBQUcsQ0FBQ1AsU0FBUyxDQUFDLEVBQUU7TUFDbEMsSUFBSSxDQUFDUCxTQUFTLENBQUNlLEdBQUcsQ0FBQ1IsU0FBUyxFQUFFLEVBQUUsQ0FBQztJQUNuQztJQUVBLE1BQU1QLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQ1QsU0FBUyxDQUFDOztJQUUvQztJQUNBLE1BQU1VLGFBQWEsR0FBR2pCLFNBQVMsQ0FBQ2tCLFNBQVMsQ0FBQ0MsUUFBUSxJQUFJQSxRQUFRLENBQUNYLFFBQVEsS0FBS0EsUUFBUSxDQUFDO0lBQ3JGLElBQUlTLGFBQWEsS0FBSyxDQUFDLENBQUMsRUFBRTtNQUN4QjtNQUNBakIsU0FBUyxDQUFDaUIsYUFBYSxDQUFDLENBQUNSLFFBQVEsR0FBR0EsUUFBUTtJQUM5QyxDQUFDLE1BQU07TUFDTDtNQUNBVCxTQUFTLENBQUNZLElBQUksQ0FBQztRQUFFSixRQUFRO1FBQUVLLElBQUksRUFBRSxLQUFLO1FBQUVKO01BQVMsQ0FBQyxDQUFDOztNQUVuRDtNQUNBVCxTQUFTLENBQUNvQixJQUFJLENBQUMsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEtBQUtBLENBQUMsQ0FBQ2IsUUFBUSxHQUFHWSxDQUFDLENBQUNaLFFBQVEsQ0FBQztJQUNuRDtJQUVBLE9BQU8sSUFBSTtFQUNiOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUksSUFBSUEsQ0FBQ04sU0FBUyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsR0FBRyxDQUFDLEVBQUU7SUFDdEM7SUFDQSxJQUFJLE9BQU9GLFNBQVMsS0FBSyxRQUFRLElBQUlBLFNBQVMsQ0FBQ0csSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7TUFDNUQsTUFBTSxJQUFJQyxLQUFLLENBQUMsdUNBQXVDLENBQUM7SUFDMUQ7SUFFQSxJQUFJLE9BQU9ILFFBQVEsS0FBSyxVQUFVLEVBQUU7TUFDbEMsTUFBTSxJQUFJRyxLQUFLLENBQUMsNkJBQTZCLENBQUM7SUFDaEQ7O0lBRUE7SUFDQSxJQUFJLElBQUksQ0FBQ1IsU0FBUyxFQUFFO01BQ2xCLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNRLElBQUksQ0FBQztRQUFFTCxTQUFTO1FBQUVDLFFBQVE7UUFBRUMsUUFBUTtRQUFFSSxJQUFJLEVBQUU7TUFBSyxDQUFDLENBQUM7TUFDMUUsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7SUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDYixTQUFTLENBQUNjLEdBQUcsQ0FBQ1AsU0FBUyxDQUFDLEVBQUU7TUFDbEMsSUFBSSxDQUFDUCxTQUFTLENBQUNlLEdBQUcsQ0FBQ1IsU0FBUyxFQUFFLEVBQUUsQ0FBQztJQUNuQztJQUVBLE1BQU1QLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQ1QsU0FBUyxDQUFDOztJQUUvQztJQUNBLE1BQU1VLGFBQWEsR0FBR2pCLFNBQVMsQ0FBQ2tCLFNBQVMsQ0FBQ0MsUUFBUSxJQUFJQSxRQUFRLENBQUNYLFFBQVEsS0FBS0EsUUFBUSxDQUFDO0lBQ3JGLElBQUlTLGFBQWEsS0FBSyxDQUFDLENBQUMsRUFBRTtNQUN4QjtNQUNBakIsU0FBUyxDQUFDaUIsYUFBYSxDQUFDLENBQUNSLFFBQVEsR0FBR0EsUUFBUTtNQUM1Q1QsU0FBUyxDQUFDaUIsYUFBYSxDQUFDLENBQUNKLElBQUksR0FBRyxJQUFJO0lBQ3RDLENBQUMsTUFBTTtNQUNMO01BQ0FiLFNBQVMsQ0FBQ1ksSUFBSSxDQUFDO1FBQUVKLFFBQVE7UUFBRUssSUFBSSxFQUFFLElBQUk7UUFBRUo7TUFBUyxDQUFDLENBQUM7O01BRWxEO01BQ0FULFNBQVMsQ0FBQ29CLElBQUksQ0FBQyxDQUFDQyxDQUFDLEVBQUVDLENBQUMsS0FBS0EsQ0FBQyxDQUFDYixRQUFRLEdBQUdZLENBQUMsQ0FBQ1osUUFBUSxDQUFDO0lBQ25EO0lBRUEsT0FBTyxJQUFJO0VBQ2I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VjLEdBQUdBLENBQUNoQixTQUFTLEVBQUVDLFFBQVEsR0FBRyxJQUFJLEVBQUU7SUFDOUI7SUFDQSxJQUFJLElBQUksQ0FBQ0wsU0FBUyxFQUFFO01BQ2xCLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUNPLElBQUksQ0FBQztRQUFFTCxTQUFTO1FBQUVDO01BQVMsQ0FBQyxDQUFDO01BQ25ELE9BQU8sSUFBSTtJQUNiOztJQUVBO0lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1IsU0FBUyxDQUFDYyxHQUFHLENBQUNQLFNBQVMsQ0FBQyxFQUFFO01BQ2xDLE9BQU8sSUFBSTtJQUNiOztJQUVBO0lBQ0EsSUFBSUMsUUFBUSxLQUFLLElBQUksRUFBRTtNQUNyQixJQUFJLENBQUNSLFNBQVMsQ0FBQ3dCLE1BQU0sQ0FBQ2pCLFNBQVMsQ0FBQztNQUNoQyxPQUFPLElBQUk7SUFDYjs7SUFFQTtJQUNBLE1BQU1QLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQ1QsU0FBUyxDQUFDO0lBQy9DLE1BQU1rQixpQkFBaUIsR0FBR3pCLFNBQVMsQ0FBQzBCLE1BQU0sQ0FBQ1AsUUFBUSxJQUFJQSxRQUFRLENBQUNYLFFBQVEsS0FBS0EsUUFBUSxDQUFDO0lBRXRGLElBQUlpQixpQkFBaUIsQ0FBQ0UsTUFBTSxLQUFLLENBQUMsRUFBRTtNQUNsQztNQUNBLElBQUksQ0FBQzNCLFNBQVMsQ0FBQ3dCLE1BQU0sQ0FBQ2pCLFNBQVMsQ0FBQztJQUNsQyxDQUFDLE1BQU07TUFDTDtNQUNBLElBQUksQ0FBQ1AsU0FBUyxDQUFDZSxHQUFHLENBQUNSLFNBQVMsRUFBRWtCLGlCQUFpQixDQUFDO0lBQ2xEO0lBRUEsT0FBTyxJQUFJO0VBQ2I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VHLElBQUlBLENBQUNyQixTQUFTLEVBQUVzQixJQUFJLEVBQUU7SUFDcEI7SUFDQSxNQUFNQyxXQUFXLEdBQUcsSUFBSSxDQUFDM0IsU0FBUztJQUNsQyxJQUFJLENBQUNBLFNBQVMsR0FBRyxJQUFJOztJQUVyQjtJQUNBLElBQUk0QixlQUFlLEdBQUcsS0FBSztJQUUzQixJQUFJO01BQ0Y7TUFDQSxJQUFJLElBQUksQ0FBQ3BDLE9BQU8sQ0FBQ0UsU0FBUyxFQUFFO1FBQzFCLElBQUksQ0FBQ21DLGFBQWEsQ0FBQ3pCLFNBQVMsRUFBRXNCLElBQUksQ0FBQztNQUNyQzs7TUFFQTtNQUNBLE1BQU1JLGdCQUFnQixHQUFHLElBQUksQ0FBQ0MseUJBQXlCLENBQUMzQixTQUFTLENBQUM7O01BRWxFO01BQ0EsS0FBSyxNQUFNNEIsSUFBSSxJQUFJRixnQkFBZ0IsRUFBRTtRQUNuQyxJQUFJLElBQUksQ0FBQ2pDLFNBQVMsQ0FBQ2MsR0FBRyxDQUFDcUIsSUFBSSxDQUFDLEVBQUU7VUFDNUIsTUFBTW5DLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQ21CLElBQUksQ0FBQztVQUMxQyxNQUFNQyxpQkFBaUIsR0FBRyxFQUFFOztVQUU1QjtVQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHckMsU0FBUyxDQUFDMkIsTUFBTSxFQUFFVSxDQUFDLEVBQUUsRUFBRTtZQUN6QyxNQUFNO2NBQUU3QixRQUFRO2NBQUVLO1lBQUssQ0FBQyxHQUFHYixTQUFTLENBQUNxQyxDQUFDLENBQUM7WUFFdkMsSUFBSTtjQUNGO2NBQ0E3QixRQUFRLENBQUNxQixJQUFJLENBQUM7Y0FDZEUsZUFBZSxHQUFHLElBQUk7O2NBRXRCO2NBQ0EsSUFBSWxCLElBQUksRUFBRTtnQkFDUnVCLGlCQUFpQixDQUFDeEIsSUFBSSxDQUFDSixRQUFRLENBQUM7Y0FDbEM7WUFDRixDQUFDLENBQUMsT0FBTzhCLEtBQUssRUFBRTtjQUNkO2NBQ0FDLE9BQU8sQ0FBQ0QsS0FBSyxDQUFDLGdDQUFnQ0gsSUFBSSxJQUFJLEVBQUVHLEtBQUssQ0FBQztZQUNoRTtVQUNGOztVQUVBO1VBQ0EsSUFBSSxDQUFDUixXQUFXLEVBQUU7WUFDaEIsS0FBSyxNQUFNdEIsUUFBUSxJQUFJNEIsaUJBQWlCLEVBQUU7Y0FDeEMsSUFBSSxDQUFDYixHQUFHLENBQUNZLElBQUksRUFBRTNCLFFBQVEsQ0FBQztZQUMxQjtVQUNGO1FBQ0Y7TUFDRjs7TUFFQTtNQUNBLElBQUksQ0FBQ3NCLFdBQVcsRUFBRTtRQUNoQixJQUFJLENBQUNVLHlCQUF5QixDQUFDLENBQUM7TUFDbEM7TUFFQSxPQUFPVCxlQUFlO0lBQ3hCLENBQUMsU0FBUztNQUNSO01BQ0EsSUFBSSxDQUFDRCxXQUFXLEVBQUU7UUFDaEIsSUFBSSxDQUFDM0IsU0FBUyxHQUFHLEtBQUs7TUFDeEI7SUFDRjtFQUNGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRXNDLFlBQVlBLENBQUNsQyxTQUFTLEVBQUU7SUFDdEI7SUFDQSxJQUFJLElBQUksQ0FBQ1AsU0FBUyxDQUFDYyxHQUFHLENBQUNQLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQ1AsU0FBUyxDQUFDZ0IsR0FBRyxDQUFDVCxTQUFTLENBQUMsQ0FBQ29CLE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDN0UsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7SUFDQSxJQUFJLElBQUksQ0FBQ2hDLE9BQU8sQ0FBQ0csZUFBZSxFQUFFO01BQ2hDLEtBQUssTUFBTSxDQUFDcUMsSUFBSSxFQUFFbkMsU0FBUyxDQUFDLElBQUksSUFBSSxDQUFDQSxTQUFTLENBQUMwQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ3hELElBQUkxQyxTQUFTLENBQUMyQixNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ2dCLGdCQUFnQixDQUFDUixJQUFJLEVBQUU1QixTQUFTLENBQUMsRUFBRTtVQUNsRSxPQUFPLElBQUk7UUFDYjtNQUNGO0lBQ0Y7SUFFQSxPQUFPLEtBQUs7RUFDZDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VxQyxhQUFhQSxDQUFDckMsU0FBUyxFQUFFO0lBQ3ZCLElBQUlzQyxLQUFLLEdBQUcsQ0FBQzs7SUFFYjtJQUNBLElBQUksSUFBSSxDQUFDN0MsU0FBUyxDQUFDYyxHQUFHLENBQUNQLFNBQVMsQ0FBQyxFQUFFO01BQ2pDc0MsS0FBSyxJQUFJLElBQUksQ0FBQzdDLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQ1QsU0FBUyxDQUFDLENBQUNvQixNQUFNO0lBQy9DOztJQUVBO0lBQ0EsSUFBSSxJQUFJLENBQUNoQyxPQUFPLENBQUNHLGVBQWUsRUFBRTtNQUNoQyxLQUFLLE1BQU0sQ0FBQ3FDLElBQUksRUFBRW5DLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQ0EsU0FBUyxDQUFDMEMsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUN4RCxJQUFJUCxJQUFJLEtBQUs1QixTQUFTLElBQUksSUFBSSxDQUFDb0MsZ0JBQWdCLENBQUNSLElBQUksRUFBRTVCLFNBQVMsQ0FBQyxFQUFFO1VBQ2hFc0MsS0FBSyxJQUFJN0MsU0FBUyxDQUFDMkIsTUFBTTtRQUMzQjtNQUNGO0lBQ0Y7SUFFQSxPQUFPa0IsS0FBSztFQUNkOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0VDLFVBQVVBLENBQUEsRUFBRztJQUNYLE9BQU9DLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQ2hELFNBQVMsQ0FBQ2lELElBQUksQ0FBQyxDQUFDLENBQUM7RUFDMUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxlQUFlQSxDQUFDQyxLQUFLLEdBQUcsRUFBRSxFQUFFO0lBQzFCLElBQUksQ0FBQyxJQUFJLENBQUN4RCxPQUFPLENBQUNFLFNBQVMsRUFBRTtNQUMzQixPQUFPLEVBQUU7SUFDWDtJQUVBLE1BQU11RCxXQUFXLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFDSCxLQUFLLEVBQUUsSUFBSSxDQUFDakQsWUFBWSxDQUFDeUIsTUFBTSxDQUFDO0lBQzdELE9BQU8sSUFBSSxDQUFDekIsWUFBWSxDQUFDcUQsS0FBSyxDQUFDLENBQUNILFdBQVcsQ0FBQztFQUM5Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFSSxrQkFBa0JBLENBQUEsRUFBRztJQUNuQixJQUFJLENBQUN4RCxTQUFTLENBQUN5RCxLQUFLLENBQUMsQ0FBQztJQUN0QixPQUFPLElBQUk7RUFDYjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFakIseUJBQXlCQSxDQUFBLEVBQUc7SUFDMUI7SUFDQSxLQUFLLE1BQU07TUFBRWpDLFNBQVM7TUFBRUM7SUFBUyxDQUFDLElBQUksSUFBSSxDQUFDSCxnQkFBZ0IsRUFBRTtNQUMzRCxJQUFJLENBQUNrQixHQUFHLENBQUNoQixTQUFTLEVBQUVDLFFBQVEsQ0FBQztJQUMvQjtJQUNBLElBQUksQ0FBQ0gsZ0JBQWdCLEdBQUcsRUFBRTs7SUFFMUI7SUFDQSxLQUFLLE1BQU07TUFBRUUsU0FBUztNQUFFQyxRQUFRO01BQUVDLFFBQVE7TUFBRUk7SUFBSyxDQUFDLElBQUksSUFBSSxDQUFDVCxpQkFBaUIsRUFBRTtNQUM1RSxJQUFJUyxJQUFJLEVBQUU7UUFDUixJQUFJLENBQUNBLElBQUksQ0FBQ04sU0FBUyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsQ0FBQztNQUMxQyxDQUFDLE1BQU07UUFDTCxJQUFJLENBQUNILEVBQUUsQ0FBQ0MsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsQ0FBQztNQUN4QztJQUNGO0lBQ0EsSUFBSSxDQUFDTCxpQkFBaUIsR0FBRyxFQUFFO0VBQzdCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFNEIsYUFBYUEsQ0FBQ3pCLFNBQVMsRUFBRXNCLElBQUksRUFBRTtJQUM3QjtJQUNBLElBQUksQ0FBQzNCLFlBQVksQ0FBQ1UsSUFBSSxDQUFDO01BQ3JCTCxTQUFTO01BQ1RzQixJQUFJO01BQ0o2QixTQUFTLEVBQUUsSUFBSUMsSUFBSSxDQUFDO0lBQ3RCLENBQUMsQ0FBQzs7SUFFRjtJQUNBLElBQUksSUFBSSxDQUFDekQsWUFBWSxDQUFDeUIsTUFBTSxHQUFHLElBQUksQ0FBQ2hDLE9BQU8sQ0FBQ0ksWUFBWSxFQUFFO01BQ3hELElBQUksQ0FBQ0csWUFBWSxDQUFDMEQsS0FBSyxDQUFDLENBQUM7SUFDM0I7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRTFCLHlCQUF5QkEsQ0FBQzNCLFNBQVMsRUFBRTtJQUNuQyxNQUFNdUMsVUFBVSxHQUFHLENBQUN2QyxTQUFTLENBQUM7O0lBRTlCO0lBQ0EsSUFBSSxJQUFJLENBQUNaLE9BQU8sQ0FBQ0MsZ0JBQWdCLElBQUlXLFNBQVMsQ0FBQ3NELFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtNQUM1RCxNQUFNQyxLQUFLLEdBQUd2RCxTQUFTLENBQUN3RCxLQUFLLENBQUMsR0FBRyxDQUFDO01BQ2xDLEtBQUssSUFBSTFCLENBQUMsR0FBR3lCLEtBQUssQ0FBQ25DLE1BQU0sR0FBRyxDQUFDLEVBQUVVLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO1FBQ3pDUyxVQUFVLENBQUNsQyxJQUFJLENBQUNrRCxLQUFLLENBQUNQLEtBQUssQ0FBQyxDQUFDLEVBQUVsQixDQUFDLENBQUMsQ0FBQzJCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUM5QztJQUNGOztJQUVBO0lBQ0EsSUFBSSxJQUFJLENBQUNyRSxPQUFPLENBQUNHLGVBQWUsRUFBRTtNQUNoQyxLQUFLLE1BQU1xQyxJQUFJLElBQUksSUFBSSxDQUFDbkMsU0FBUyxDQUFDaUQsSUFBSSxDQUFDLENBQUMsRUFBRTtRQUN4QyxJQUFJLENBQUNILFVBQVUsQ0FBQ2UsUUFBUSxDQUFDMUIsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDUSxnQkFBZ0IsQ0FBQ1IsSUFBSSxFQUFFNUIsU0FBUyxDQUFDLEVBQUU7VUFDeEV1QyxVQUFVLENBQUNsQyxJQUFJLENBQUN1QixJQUFJLENBQUM7UUFDdkI7TUFDRjtJQUNGO0lBRUEsT0FBT1csVUFBVTtFQUNuQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFSCxnQkFBZ0JBLENBQUNzQixPQUFPLEVBQUUxRCxTQUFTLEVBQUU7SUFDbkM7SUFDQSxJQUFJMEQsT0FBTyxDQUFDdEMsTUFBTSxHQUFHLElBQUksSUFBSXBCLFNBQVMsQ0FBQ29CLE1BQU0sR0FBRyxJQUFJLEVBQUU7TUFDcERZLE9BQU8sQ0FBQzJCLElBQUksQ0FBQyw0RUFBNEUsQ0FBQztNQUMxRixPQUFPLEtBQUs7SUFDZDs7SUFFQTtJQUNBLElBQUlELE9BQU8sS0FBSzFELFNBQVMsRUFBRTtNQUN6QixPQUFPLElBQUk7SUFDYjs7SUFFQTtJQUNBLElBQUkwRCxPQUFPLEtBQUssR0FBRyxFQUFFO01BQ25CLE9BQU8sQ0FBQzFELFNBQVMsQ0FBQ3NELFFBQVEsQ0FBQyxHQUFHLENBQUM7SUFDakM7SUFFQSxJQUFJSSxPQUFPLEtBQUssSUFBSSxFQUFFO01BQ3BCLE9BQU8sSUFBSTtJQUNiOztJQUVBO0lBQ0EsSUFBSUEsT0FBTyxDQUFDSixRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7TUFDMUIsTUFBTUMsS0FBSyxHQUFHRyxPQUFPLENBQUNGLEtBQUssQ0FBQyxJQUFJLENBQUM7O01BRWpDO01BQ0EsSUFBSUQsS0FBSyxDQUFDbkMsTUFBTSxLQUFLLENBQUMsSUFBSW1DLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7UUFDekMsT0FBT3ZELFNBQVMsQ0FBQzRELFVBQVUsQ0FBQ0wsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3ZDOztNQUVBO01BQ0EsSUFBSUEsS0FBSyxDQUFDbkMsTUFBTSxLQUFLLENBQUMsSUFBSW1DLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7UUFDekMsT0FBT3ZELFNBQVMsQ0FBQzZELFFBQVEsQ0FBQ04sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3JDOztNQUVBO01BQ0EsSUFBSUEsS0FBSyxDQUFDbkMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN0QixPQUFPcEIsU0FBUyxDQUFDNEQsVUFBVSxDQUFDTCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSXZELFNBQVMsQ0FBQzZELFFBQVEsQ0FBQ04sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3ZFO0lBQ0Y7O0lBRUE7SUFDQSxJQUFJRyxPQUFPLENBQUNKLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDSSxPQUFPLENBQUNKLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtNQUNwRCxJQUFJO1FBQ0YsTUFBTVEsWUFBWSxHQUFHLEdBQUcsR0FBR0osT0FBTyxDQUFDSyxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDQSxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDdEYsTUFBTUMsS0FBSyxHQUFHLElBQUlDLE1BQU0sQ0FBQ0gsWUFBWSxDQUFDO1FBQ3RDLE9BQU9FLEtBQUssQ0FBQ0UsSUFBSSxDQUFDbEUsU0FBUyxDQUFDO01BQzlCLENBQUMsQ0FBQyxPQUFPbUUsQ0FBQyxFQUFFO1FBQ1ZuQyxPQUFPLENBQUNELEtBQUssQ0FBQyx3QkFBd0IsRUFBRTJCLE9BQU8sQ0FBQztRQUNoRCxPQUFPLEtBQUs7TUFDZDtJQUNGO0lBRUEsT0FBTyxLQUFLO0VBQ2Q7QUFDRjtBQUVBVSxNQUFNLENBQUNDLE9BQU8sR0FBR25GLFdBQVciLCJpZ25vcmVMaXN0IjpbXX0=