{"version":3,"names":["EventSystem","constructor","options","enableNamespaces","debugMode","enableWildcards","historyLimit","shareOnceListeners","listeners","Map","eventHistory","_emitting","_pendingAdditions","_pendingRemovals","_executedCallbacks","Set","_originalToWrapper","_wrapperToEvents","on","eventName","callback","priority","trim","Error","push","once","has","set","get","existingIndex","findIndex","listener","sort","a","b","wrapper","add","args","eventNames","eventNamesCopy","name","off","delete","_currentEventName","size","apply","events","original","w","entries","filteredListeners","filter","length","emit","data","wasEmitting","clear","listenersCalled","_addToHistory","eventNamesToEmit","_getEventNamesForEmission","listenersToRemove","originalCallback","previousEventName","error","console","updatedListeners","l","_processPendingOperations","hasListeners","checked","maxToCheck","includes","_matchesWildcard","listenerCount","count","Array","from","keys","getEventHistory","limit","actualLimit","Math","min","slice","removeAllListeners","maxOperations","removalsToProcess","i","additionsToProcess","timestamp","Date","shift","parts","split","parentName","maxListenersToCheck","checkedCount","pattern","startsWith","endsWith","patternParts","eventParts","module","exports"],"sources":["EventSystem.js"],"sourcesContent":["/**\n * EventSystem - Core event management module for the werewolf game GM support library\n *\n * This module provides the foundation for the event-driven architecture,\n * enabling communication between different modules through events.\n */\n\nclass EventSystem {\n  /**\n   * Creates a new EventSystem instance\n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.enableNamespaces=true] - Enable hierarchical event namespaces\n   * @param {boolean} [options.debugMode=false] - Enable debug mode with event history\n   * @param {boolean} [options.enableWildcards=false] - Enable wildcard event matching\n   * @param {number} [options.historyLimit=100] - Maximum number of events to keep in history\n   * @param {boolean} [options.shareOnceListeners=false] - Whether once listeners should be shared across event names\n   */\n  constructor(options = {}) {\n    // Default options\n    this.options = {\n      enableNamespaces: true,\n      debugMode: false,\n      enableWildcards: false, \n      historyLimit: 100,\n      shareOnceListeners: false,\n      ...options\n    };\n\n    // Map to store event listeners: { eventName => [{ callback, once, priority }] }\n    this.listeners = new Map();\n\n    // Event history for debugging (only active in debug mode)\n    this.eventHistory = [];\n\n    // Flag to track if we're currently emitting an event (to handle nested emissions)\n    this._emitting = false;\n\n    // Queue for listeners to be added/removed during emission\n    this._pendingAdditions = [];\n    this._pendingRemovals = [];\n    \n    // Set to track which original callbacks have been executed\n    this._executedCallbacks = new Set();\n    \n    // Map to track original callbacks to wrappers\n    this._originalToWrapper = new Map();\n    \n    // Map to track wrappers to event names\n    this._wrapperToEvents = new Map();\n  }\n\n  /**\n   * Register an event listener\n   * @param {string} eventName - Name of the event to listen for\n   * @param {Function} callback - Function to call when the event is emitted\n   * @param {number} [priority=0] - Priority of the listener (higher executes first)\n   * @return {EventSystem} - Returns this instance for chaining\n   * @throws {Error} If eventName is not a string or callback is not a function\n   */\n  on(eventName, callback, priority = 0) {\n    // Validate arguments\n    if (typeof eventName !== 'string' || eventName.trim() === '') {\n      throw new Error('Event name must be a non-empty string');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n\n    // If we're currently emitting, queue the addition\n    if (this._emitting) {\n      this._pendingAdditions.push({ eventName, callback, priority, once: false });\n      return this;\n    }\n\n    // Get or create the listeners array for this event\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, []);\n    }\n\n    const listeners = this.listeners.get(eventName);\n\n    // Check for duplicate listener\n    const existingIndex = listeners.findIndex(listener => listener.callback === callback);\n    if (existingIndex !== -1) {\n      // Update the existing listener's priority\n      listeners[existingIndex].priority = priority;\n    } else {\n      // Add the new listener\n      listeners.push({ callback, once: false, priority });\n\n      // Sort listeners by priority (highest first)\n      listeners.sort((a, b) => b.priority - a.priority);\n    }\n\n    return this;\n  }\n\n  /**\n   * Register a one-time event listener that will be removed after execution\n   * @param {string} eventName - Name of the event to listen for\n   * @param {Function} callback - Function to call when the event is emitted\n   * @param {number} [priority=0] - Priority of the listener (higher executes first)\n   * @return {EventSystem} - Returns this instance for chaining\n   * @throws {Error} If eventName is not a string or callback is not a function\n   */\n  once(eventName, callback, priority = 0) {\n    // Validate arguments\n    if (typeof eventName !== 'string' || eventName.trim() === '') {\n      throw new Error('Event name must be a non-empty string');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n    \n    let wrapper;\n    \n    // Check if we already have a wrapper for this callback\n    if (this._originalToWrapper.has(callback)) {\n      wrapper = this._originalToWrapper.get(callback);\n      \n      // Add this event name to the wrapper's tracked events\n      if (!this._wrapperToEvents.has(wrapper)) {\n        this._wrapperToEvents.set(wrapper, new Set());\n      }\n      this._wrapperToEvents.get(wrapper).add(eventName);\n    } else {\n      // Create a new wrapper function\n      wrapper = (...args) => {\n        // Remove this listener before calling the callback to prevent recursion issues\n        \n        if (this.options.shareOnceListeners) {\n          // In shared mode, remove this wrapper from all events it's registered for\n          const eventNames = this._wrapperToEvents.get(wrapper);\n          if (eventNames) {\n            // Create a copy to avoid issues with modification during iteration\n            const eventNamesCopy = [...eventNames];\n            for (const name of eventNamesCopy) {\n              this.off(name, wrapper);\n            }\n          }\n          \n          // Clean up our tracking maps\n          this._wrapperToEvents.delete(wrapper);\n          this._originalToWrapper.delete(callback);\n        } else {\n          // In standard mode, only remove from the current event\n          if (this._currentEventName) {\n            this.off(this._currentEventName, wrapper);\n            \n            // Update the wrapper's tracked events\n            const eventNames = this._wrapperToEvents.get(wrapper);\n            if (eventNames) {\n              eventNames.delete(this._currentEventName);\n              \n              // If the wrapper isn't used for any events anymore, clean up tracking\n              if (eventNames.size === 0) {\n                this._wrapperToEvents.delete(wrapper);\n                this._originalToWrapper.delete(callback);\n              }\n            }\n          }\n        }\n        \n        // Call the original callback with the proper context\n        return callback.apply(this, args);\n      };\n      \n      // Set up tracking\n      this._originalToWrapper.set(callback, wrapper);\n      this._wrapperToEvents.set(wrapper, new Set([eventName]));\n    }\n\n    // If we're currently emitting, queue the addition\n    if (this._emitting) {\n      this._pendingAdditions.push({ eventName, callback: wrapper, priority, once: true });\n      return this;\n    }\n\n    // Get or create the listeners array for this event\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, []);\n    }\n\n    const listeners = this.listeners.get(eventName);\n\n    // Check for duplicate listener\n    const existingIndex = listeners.findIndex(listener => listener.callback === wrapper);\n    if (existingIndex !== -1) {\n      // Update the existing listener's priority\n      listeners[existingIndex].priority = priority;\n    } else {\n      // Add the new listener with the wrapper as callback\n      listeners.push({ callback: wrapper, once: true, priority });\n\n      // Sort listeners by priority (highest first)\n      listeners.sort((a, b) => b.priority - a.priority);\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove an event listener\n   * @param {string} eventName - Name of the event to remove listener from\n   * @param {Function} [callback] - Specific callback to remove (if omitted, all listeners for the event are removed)\n   * @return {EventSystem} - Returns this instance for chaining\n   */\n  off(eventName, callback = null) {\n    // If we're currently emitting, queue the removal\n    if (this._emitting) {\n      this._pendingRemovals.push({ eventName, callback });\n      return this;\n    }\n\n    // If eventName doesn't exist, nothing to do\n    if (!this.listeners.has(eventName)) {\n      return this;\n    }\n\n    // If callback is null, remove all listeners for this event\n    if (callback === null) {\n      // Update tracking for 'once' listeners that are being removed\n      const listeners = this.listeners.get(eventName);\n      for (const listener of listeners) {\n        if (listener.once) {\n          const wrapper = listener.callback;\n          const events = this._wrapperToEvents.get(wrapper);\n          if (events) {\n            events.delete(eventName);\n            if (events.size === 0) {\n              for (const [original, w] of this._originalToWrapper.entries()) {\n                if (w === wrapper) {\n                  this._originalToWrapper.delete(original);\n                  break;\n                }\n              }\n              this._wrapperToEvents.delete(wrapper);\n            }\n          }\n        }\n      }\n      \n      this.listeners.delete(eventName);\n      return this;\n    }\n\n    // Otherwise, only remove the specific callback\n    const listeners = this.listeners.get(eventName);\n    const filteredListeners = listeners.filter(listener => listener.callback !== callback);\n\n    if (filteredListeners.length === 0) {\n      // If no listeners remain, remove the event entirely\n      this.listeners.delete(eventName);\n    } else {\n      // Otherwise, update the listeners array\n      this.listeners.set(eventName, filteredListeners);\n    }\n\n    // Update tracking for a 'once' listener being removed\n    if (this._wrapperToEvents.has(callback)) {\n      const events = this._wrapperToEvents.get(callback);\n      events.delete(eventName);\n      if (events.size === 0) {\n        for (const [original, wrapper] of this._originalToWrapper.entries()) {\n          if (wrapper === callback) {\n            this._originalToWrapper.delete(original);\n            break;\n          }\n        }\n        this._wrapperToEvents.delete(callback);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   * @param {string} eventName - Name of the event to emit\n   * @param {*} [data] - Data to pass to the listeners\n   * @return {boolean} - True if the event had listeners, false otherwise\n   */\n  emit(eventName, data) {\n    // Mark that we're emitting an event\n    const wasEmitting = this._emitting;\n    this._emitting = true;\n\n    // Clear executed callbacks set at the start of an emission cycle\n    if (!wasEmitting) {\n      this._executedCallbacks.clear();\n    }\n\n    // Track whether any listeners were called\n    let listenersCalled = false;\n\n    try {\n      // Add to history if debug mode is enabled\n      if (this.options.debugMode) {\n        this._addToHistory(eventName, data);\n      }\n\n      // Get all event names to emit based on the options\n      const eventNamesToEmit = this._getEventNamesForEmission(eventName);\n      \n      // Track listeners to be removed after execution\n      const listenersToRemove = [];\n\n      // Emit to each matched event name\n      for (const name of eventNamesToEmit) {\n        if (!this.listeners.has(name)) continue;\n        \n        // Clone the listener array to avoid issues with modifications during iteration\n        const listeners = [...this.listeners.get(name)];\n\n        // Call each listener\n        for (const listener of listeners) {\n          const { callback, once } = listener;\n          \n          // If this is a 'once' listener for a callback that's already been executed\n          // in this emission cycle in shared mode, skip it\n          if (this.options.shareOnceListeners && once) {\n            // Find the original callback\n            let originalCallback = null;\n            for (const [original, wrapper] of this._originalToWrapper.entries()) {\n              if (wrapper === callback) {\n                originalCallback = original;\n                break;\n              }\n            }\n            \n            // If we found the original and it's already been executed, skip and remove\n            if (originalCallback && this._executedCallbacks.has(originalCallback)) {\n              listenersToRemove.push({ name, callback });\n              continue;\n            }\n            \n            // If the original is found, mark it as executed\n            if (originalCallback) {\n              this._executedCallbacks.add(originalCallback);\n            }\n          }\n\n          try {\n            // Set current event name for context in the wrapper\n            const previousEventName = this._currentEventName;\n            this._currentEventName = name;\n            \n            // Call the listener with the event data\n            callback(data);\n            listenersCalled = true;\n\n            // Restore previous event name\n            this._currentEventName = previousEventName;\n\n            // If it's a once listener and hasn't removed itself, mark for removal\n            if (once) {\n              listenersToRemove.push({ name, callback });\n            }\n          } catch (error) {\n            // Log the error but continue with other listeners\n            console.error(`Error in event listener for '${name}':`, error);\n          }\n        }\n      }\n\n      // Remove all marked listeners\n      for (const { name, callback } of listenersToRemove) {\n        // Skip if the event no longer exists\n        if (!this.listeners.has(name)) continue;\n        \n        // Get the current listeners\n        const listeners = this.listeners.get(name);\n        \n        // Filter out the callback\n        const updatedListeners = listeners.filter(l => l.callback !== callback);\n        \n        // Update or delete the event\n        if (updatedListeners.length === 0) {\n          this.listeners.delete(name);\n        } else {\n          this.listeners.set(name, updatedListeners);\n        }\n      }\n\n      // Process pending operations if this is the outermost emit\n      if (!wasEmitting) {\n        this._processPendingOperations();\n      }\n\n      return listenersCalled;\n    } finally {\n      // Reset the emitting flag if this is the outermost emit\n      if (!wasEmitting) {\n        this._emitting = false;\n      }\n    }\n  }\n\n  /**\n   * Check if an event has any listeners\n   * @param {string} eventName - Name of the event to check\n   * @return {boolean} - True if the event has listeners, false otherwise\n   */\n  hasListeners(eventName) {\n    // Direct match\n    if (this.listeners.has(eventName) && this.listeners.get(eventName).length > 0) {\n      return true;\n    }\n\n    // If wildcards are enabled, check for wildcard matches\n    if (this.options.enableWildcards) {\n      // 最適化: 最大チェック数を制限\n      let checked = 0;\n      const maxToCheck = 100;\n      \n      for (const [name, listeners] of this.listeners.entries()) {\n        if (++checked > maxToCheck) break;\n        \n        if (listeners.length > 0 && name.includes('*') && this._matchesWildcard(name, eventName)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the number of listeners for an event\n   * @param {string} eventName - Name of the event to check\n   * @return {number} - Number of listeners for the event\n   */\n  listenerCount(eventName) {\n    let count = 0;\n\n    // Direct match\n    if (this.listeners.has(eventName)) {\n      count += this.listeners.get(eventName).length;\n    }\n\n    // If wildcards are enabled, check for wildcard matches\n    if (this.options.enableWildcards) {\n      // 最適化: 最大チェック数を制限\n      let checked = 0;\n      const maxToCheck = 100;\n      \n      for (const [name, listeners] of this.listeners.entries()) {\n        if (++checked > maxToCheck) break;\n        \n        if (name !== eventName && name.includes('*') && this._matchesWildcard(name, eventName)) {\n          count += listeners.length;\n        }\n      }\n    }\n\n    return count;\n  }\n\n  /**\n   * Get all registered event names\n   * @return {string[]} - Array of registered event names\n   */\n  eventNames() {\n    return Array.from(this.listeners.keys());\n  }\n\n  /**\n   * Get the recent event history (only available in debug mode)\n   * @param {number} [limit=10] - Maximum number of events to return\n   * @return {Array} - Array of recent events or empty array if debug mode is disabled\n   */\n  getEventHistory(limit = 10) {\n    if (!this.options.debugMode) {\n      return [];\n    }\n\n    const actualLimit = Math.min(limit, this.eventHistory.length);\n    return this.eventHistory.slice(-actualLimit);\n  }\n\n  /**\n   * Clear all event listeners\n   * @return {EventSystem} - Returns this instance for chaining\n   */\n  removeAllListeners() {\n    this.listeners.clear();\n    \n    // Also clear all tracking maps\n    this._originalToWrapper.clear();\n    this._wrapperToEvents.clear();\n    \n    return this;\n  }\n\n  /**\n   * Process pending listener additions and removals\n   * @private\n   */\n  _processPendingOperations() {\n    // 最適化: 大量のペンディング操作がある場合のガード\n    const maxOperations = 1000;\n    \n    // Process removals first to avoid issues with additions that would be immediately removed\n    const removalsToProcess = Math.min(this._pendingRemovals.length, maxOperations);\n    for (let i = 0; i < removalsToProcess; i++) {\n      const { eventName, callback } = this._pendingRemovals[i];\n      this.off(eventName, callback);\n    }\n    \n    // 処理した分だけ配列から削除\n    if (removalsToProcess === this._pendingRemovals.length) {\n      this._pendingRemovals = [];\n    } else {\n      this._pendingRemovals = this._pendingRemovals.slice(removalsToProcess);\n    }\n\n    // Then process additions\n    const additionsToProcess = Math.min(this._pendingAdditions.length, maxOperations);\n    for (let i = 0; i < additionsToProcess; i++) {\n      const { eventName, callback, priority, once } = this._pendingAdditions[i];\n      if (once) {\n        this.once(eventName, callback, priority);\n      } else {\n        this.on(eventName, callback, priority);\n      }\n    }\n    \n    // 処理した分だけ配列から削除\n    if (additionsToProcess === this._pendingAdditions.length) {\n      this._pendingAdditions = [];\n    } else {\n      this._pendingAdditions = this._pendingAdditions.slice(additionsToProcess);\n    }\n  }\n\n  /**\n   * Add an event to the history\n   * @param {string} eventName - Name of the emitted event\n   * @param {*} data - Data passed with the event\n   * @private\n   */\n  _addToHistory(eventName, data) {\n    // Add to history with timestamp\n    this.eventHistory.push({\n      eventName,\n      data,\n      timestamp: new Date()\n    });\n\n    // Trim history if it exceeds the limit\n    if (this.eventHistory.length > this.options.historyLimit) {\n      this.eventHistory.shift();\n    }\n  }\n\n  /**\n   * Get all event names to emit based on the original event and options\n   * @param {string} eventName - The original event name\n   * @return {string[]} - Array of event names to emit\n   * @private\n   */\n  _getEventNamesForEmission(eventName) {\n    const eventNames = [eventName];\n\n    // Add namespace parent events if enabled\n    if (this.options.enableNamespaces && eventName.includes('.')) {\n      const parts = eventName.split('.');\n      // 最適化: 一度に全部を計算せず徐々に親名前空間を構築\n      let parentName = '';\n      for (let i = 0; i < parts.length - 1; i++) {\n        parentName = parentName ? `${parentName}.${parts[i]}` : parts[i];\n        eventNames.push(parentName);\n      }\n    }\n\n    // 最適化: ワイルドカードが有効な場合は、必要なリスナーのみマッチングする\n    if (this.options.enableWildcards) {\n      // 最適化: リスナーの数が多すぎる場合は制限する\n      const maxListenersToCheck = 100;\n      let checkedCount = 0;\n      \n      for (const name of this.listeners.keys()) {\n        // ワイルドカード文字を含む場合のみチェック\n        if (!name.includes('*')) continue;\n        \n        // 処理済みのイベント名はスキップ\n        if (eventNames.includes(name)) continue;\n        \n        // 最大制限に達したら停止\n        if (++checkedCount > maxListenersToCheck) {\n          break;\n        }\n        \n        // ワイルドカードパターンの簡易チェック\n        if (this._matchesWildcard(name, eventName)) {\n          eventNames.push(name);\n        }\n      }\n    }\n\n    return eventNames;\n  }\n\n  /**\n   * Check if a wildcard pattern matches an event name\n   * @param {string} pattern - The wildcard pattern to check\n   * @param {string} eventName - The event name to match against\n   * @return {boolean} - True if the pattern matches the event name\n   * @private\n   */\n  _matchesWildcard(pattern, eventName) {\n    // パターンや名前が異常に長い場合はマッチングを諦める（安全対策）\n    if (pattern.length > 1000 || eventName.length > 1000) {\n      return false;\n    }\n\n    // 単純なチェック\n    if (pattern === eventName) {\n      return true;\n    }\n\n    // 単純なワイルドカードチェック\n    if (pattern === '*') {\n      return !eventName.includes('.');\n    }\n\n    if (pattern === '**') {\n      return true;\n    }\n\n    // 複数階層のワイルドカード (**) の処理\n    if (pattern.includes('**')) {\n      const parts = pattern.split('**');\n      \n      // 最適化: 最大2つのパートのみをサポート\n      if (parts.length > 2) {\n        return false;\n      }\n\n      // パターンが 'game.**' のような形式の場合\n      if (parts.length === 2 && parts[1] === '') {\n        return eventName.startsWith(parts[0]);\n      }\n\n      // パターンが '**.end' のような形式の場合\n      if (parts.length === 2 && parts[0] === '') {\n        return eventName.endsWith(parts[1]);\n      }\n\n      // パターンが 'start.**.end' のような形式の場合\n      if (parts.length === 2) {\n        return eventName.startsWith(parts[0]) && eventName.endsWith(parts[1]);\n      }\n    }\n\n    // 単一階層のワイルドカード (*) の処理\n    if (pattern.includes('*') && !pattern.includes('**')) {\n      // 正規表現を使わない最適化された方法\n      const patternParts = pattern.split('.');\n      const eventParts = eventName.split('.');\n      \n      if (patternParts.length !== eventParts.length) {\n        return false;\n      }\n      \n      for (let i = 0; i < patternParts.length; i++) {\n        if (patternParts[i] === '*') {\n          continue; // ワイルドカードは何にもマッチする\n        }\n        if (patternParts[i] !== eventParts[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = EventSystem;"],"mappings":"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","ignoreList":[]}