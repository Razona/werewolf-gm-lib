{"version":3,"names":["EventSystem","constructor","options","enableNamespaces","debugMode","enableWildcards","historyLimit","listeners","Map","eventHistory","_emitting","_pendingAdditions","_pendingRemovals","on","eventName","callback","priority","trim","Error","push","once","has","set","get","existingIndex","findIndex","listener","sort","a","b","off","delete","filteredListeners","filter","length","emit","data","wasEmitting","listenersCalled","_addToHistory","eventNamesToEmit","_getEventNamesForEmission","name","listenersToRemove","i","error","console","_processPendingOperations","hasListeners","entries","_matchesWildcard","listenerCount","count","eventNames","Array","from","keys","getEventHistory","limit","actualLimit","Math","min","slice","removeAllListeners","clear","timestamp","Date","shift","includes","parts","split","join","pattern","regex","RegExp","replace","test","module","exports"],"sources":["EventSystem.js"],"sourcesContent":["/**\n * EventSystem - Core event management module for the werewolf game GM support library\n * \n * This module provides the foundation for the event-driven architecture,\n * enabling communication between different modules through events.\n */\n\nclass EventSystem {\n  /**\n   * Creates a new EventSystem instance\n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.enableNamespaces=true] - Enable hierarchical event namespaces\n   * @param {boolean} [options.debugMode=false] - Enable debug mode with event history\n   * @param {boolean} [options.enableWildcards=false] - Enable wildcard event matching\n   * @param {number} [options.historyLimit=100] - Maximum number of events to keep in history\n   */\n  constructor(options = {}) {\n    // Default options\n    this.options = {\n      enableNamespaces: true,\n      debugMode: false,\n      enableWildcards: false,\n      historyLimit: 100,\n      ...options\n    };\n\n    // Map to store event listeners: { eventName => [{ callback, once, priority }] }\n    this.listeners = new Map();\n    \n    // Event history for debugging (only active in debug mode)\n    this.eventHistory = [];\n    \n    // Flag to track if we're currently emitting an event (to handle nested emissions)\n    this._emitting = false;\n    \n    // Queue for listeners to be added/removed during emission\n    this._pendingAdditions = [];\n    this._pendingRemovals = [];\n  }\n\n  /**\n   * Register an event listener\n   * @param {string} eventName - Name of the event to listen for\n   * @param {Function} callback - Function to call when the event is emitted\n   * @param {number} [priority=0] - Priority of the listener (higher executes first)\n   * @return {EventSystem} - Returns this instance for chaining\n   * @throws {Error} If eventName is not a string or callback is not a function\n   */\n  on(eventName, callback, priority = 0) {\n    // Validate arguments\n    if (typeof eventName !== 'string' || eventName.trim() === '') {\n      throw new Error('Event name must be a non-empty string');\n    }\n    \n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n    \n    // If we're currently emitting, queue the addition\n    if (this._emitting) {\n      this._pendingAdditions.push({ eventName, callback, priority, once: false });\n      return this;\n    }\n\n    // Get or create the listeners array for this event\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, []);\n    }\n    \n    const listeners = this.listeners.get(eventName);\n    \n    // Check for duplicate listener\n    const existingIndex = listeners.findIndex(listener => listener.callback === callback);\n    if (existingIndex !== -1) {\n      // Update the existing listener's priority\n      listeners[existingIndex].priority = priority;\n    } else {\n      // Add the new listener\n      listeners.push({ callback, once: false, priority });\n      \n      // Sort listeners by priority (highest first)\n      listeners.sort((a, b) => b.priority - a.priority);\n    }\n    \n    return this;\n  }\n\n  /**\n   * Register a one-time event listener that will be removed after execution\n   * @param {string} eventName - Name of the event to listen for\n   * @param {Function} callback - Function to call when the event is emitted\n   * @param {number} [priority=0] - Priority of the listener (higher executes first)\n   * @return {EventSystem} - Returns this instance for chaining\n   * @throws {Error} If eventName is not a string or callback is not a function\n   */\n  once(eventName, callback, priority = 0) {\n    // Validate arguments\n    if (typeof eventName !== 'string' || eventName.trim() === '') {\n      throw new Error('Event name must be a non-empty string');\n    }\n    \n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n    \n    // If we're currently emitting, queue the addition\n    if (this._emitting) {\n      this._pendingAdditions.push({ eventName, callback, priority, once: true });\n      return this;\n    }\n\n    // Get or create the listeners array for this event\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, []);\n    }\n    \n    const listeners = this.listeners.get(eventName);\n    \n    // Check for duplicate listener\n    const existingIndex = listeners.findIndex(listener => listener.callback === callback);\n    if (existingIndex !== -1) {\n      // Update the existing listener's priority and once flag\n      listeners[existingIndex].priority = priority;\n      listeners[existingIndex].once = true;\n    } else {\n      // Add the new listener\n      listeners.push({ callback, once: true, priority });\n      \n      // Sort listeners by priority (highest first)\n      listeners.sort((a, b) => b.priority - a.priority);\n    }\n    \n    return this;\n  }\n\n  /**\n   * Remove an event listener\n   * @param {string} eventName - Name of the event to remove listener from\n   * @param {Function} [callback] - Specific callback to remove (if omitted, all listeners for the event are removed)\n   * @return {EventSystem} - Returns this instance for chaining\n   */\n  off(eventName, callback = null) {\n    // If we're currently emitting, queue the removal\n    if (this._emitting) {\n      this._pendingRemovals.push({ eventName, callback });\n      return this;\n    }\n\n    // If eventName doesn't exist, nothing to do\n    if (!this.listeners.has(eventName)) {\n      return this;\n    }\n    \n    // If callback is null, remove all listeners for this event\n    if (callback === null) {\n      this.listeners.delete(eventName);\n      return this;\n    }\n    \n    // Otherwise, only remove the specific callback\n    const listeners = this.listeners.get(eventName);\n    const filteredListeners = listeners.filter(listener => listener.callback !== callback);\n    \n    if (filteredListeners.length === 0) {\n      // If no listeners remain, remove the event entirely\n      this.listeners.delete(eventName);\n    } else {\n      // Otherwise, update the listeners array\n      this.listeners.set(eventName, filteredListeners);\n    }\n    \n    return this;\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   * @param {string} eventName - Name of the event to emit\n   * @param {*} [data] - Data to pass to the listeners\n   * @return {boolean} - True if the event had listeners, false otherwise\n   */\n  emit(eventName, data) {\n    // Mark that we're emitting an event\n    const wasEmitting = this._emitting;\n    this._emitting = true;\n    \n    // Track whether any listeners were called\n    let listenersCalled = false;\n    \n    try {\n      // Add to history if debug mode is enabled\n      if (this.options.debugMode) {\n        this._addToHistory(eventName, data);\n      }\n      \n      // Get all event names to emit based on the options\n      const eventNamesToEmit = this._getEventNamesForEmission(eventName);\n      \n      // Emit to each matched event name\n      for (const name of eventNamesToEmit) {\n        if (this.listeners.has(name)) {\n          const listeners = this.listeners.get(name);\n          const listenersToRemove = [];\n          \n          // Call each listener\n          for (let i = 0; i < listeners.length; i++) {\n            const { callback, once } = listeners[i];\n            \n            try {\n              // Call the listener with the event data\n              callback(data);\n              listenersCalled = true;\n              \n              // If it's a once listener, mark it for removal\n              if (once) {\n                listenersToRemove.push(callback);\n              }\n            } catch (error) {\n              // Log the error but continue with other listeners\n              console.error(`Error in event listener for '${name}':`, error);\n            }\n          }\n          \n          // Remove once listeners (if we're not in a nested emit)\n          if (!wasEmitting) {\n            for (const callback of listenersToRemove) {\n              this.off(name, callback);\n            }\n          }\n        }\n      }\n      \n      // Process pending additions and removals (if we're not in a nested emit)\n      if (!wasEmitting) {\n        this._processPendingOperations();\n      }\n      \n      return listenersCalled;\n    } finally {\n      // Only reset the emitting flag if we're the outermost emit call\n      if (!wasEmitting) {\n        this._emitting = false;\n      }\n    }\n  }\n\n  /**\n   * Check if an event has any listeners\n   * @param {string} eventName - Name of the event to check\n   * @return {boolean} - True if the event has listeners, false otherwise\n   */\n  hasListeners(eventName) {\n    // Direct match\n    if (this.listeners.has(eventName) && this.listeners.get(eventName).length > 0) {\n      return true;\n    }\n    \n    // If wildcards are enabled, check for wildcard matches\n    if (this.options.enableWildcards) {\n      for (const [name, listeners] of this.listeners.entries()) {\n        if (listeners.length > 0 && this._matchesWildcard(name, eventName)) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get the number of listeners for an event\n   * @param {string} eventName - Name of the event to check\n   * @return {number} - Number of listeners for the event\n   */\n  listenerCount(eventName) {\n    let count = 0;\n    \n    // Direct match\n    if (this.listeners.has(eventName)) {\n      count += this.listeners.get(eventName).length;\n    }\n    \n    // If wildcards are enabled, check for wildcard matches\n    if (this.options.enableWildcards) {\n      for (const [name, listeners] of this.listeners.entries()) {\n        if (name !== eventName && this._matchesWildcard(name, eventName)) {\n          count += listeners.length;\n        }\n      }\n    }\n    \n    return count;\n  }\n\n  /**\n   * Get all registered event names\n   * @return {string[]} - Array of registered event names\n   */\n  eventNames() {\n    return Array.from(this.listeners.keys());\n  }\n\n  /**\n   * Get the recent event history (only available in debug mode)\n   * @param {number} [limit=10] - Maximum number of events to return\n   * @return {Array} - Array of recent events or empty array if debug mode is disabled\n   */\n  getEventHistory(limit = 10) {\n    if (!this.options.debugMode) {\n      return [];\n    }\n    \n    const actualLimit = Math.min(limit, this.eventHistory.length);\n    return this.eventHistory.slice(-actualLimit);\n  }\n\n  /**\n   * Clear all event listeners\n   * @return {EventSystem} - Returns this instance for chaining\n   */\n  removeAllListeners() {\n    this.listeners.clear();\n    return this;\n  }\n\n  /**\n   * Process pending listener additions and removals\n   * @private\n   */\n  _processPendingOperations() {\n    // Process removals first to avoid issues with additions that would be immediately removed\n    for (const { eventName, callback } of this._pendingRemovals) {\n      this.off(eventName, callback);\n    }\n    this._pendingRemovals = [];\n    \n    // Then process additions\n    for (const { eventName, callback, priority, once } of this._pendingAdditions) {\n      if (once) {\n        this.once(eventName, callback, priority);\n      } else {\n        this.on(eventName, callback, priority);\n      }\n    }\n    this._pendingAdditions = [];\n  }\n\n  /**\n   * Add an event to the history\n   * @param {string} eventName - Name of the emitted event\n   * @param {*} data - Data passed with the event\n   * @private\n   */\n  _addToHistory(eventName, data) {\n    // Add to history with timestamp\n    this.eventHistory.push({\n      eventName,\n      data,\n      timestamp: new Date()\n    });\n    \n    // Trim history if it exceeds the limit\n    if (this.eventHistory.length > this.options.historyLimit) {\n      this.eventHistory.shift();\n    }\n  }\n\n  /**\n   * Get all event names to emit based on the original event and options\n   * @param {string} eventName - The original event name\n   * @return {string[]} - Array of event names to emit\n   * @private\n   */\n  _getEventNamesForEmission(eventName) {\n    const eventNames = [eventName];\n    \n    // Add namespace parent events if enabled\n    if (this.options.enableNamespaces && eventName.includes('.')) {\n      const parts = eventName.split('.');\n      for (let i = parts.length - 1; i > 0; i--) {\n        eventNames.push(parts.slice(0, i).join('.'));\n      }\n    }\n    \n    // Add wildcard matches if enabled\n    if (this.options.enableWildcards) {\n      for (const name of this.listeners.keys()) {\n        if (!eventNames.includes(name) && this._matchesWildcard(name, eventName)) {\n          eventNames.push(name);\n        }\n      }\n    }\n    \n    return eventNames;\n  }\n\n  /**\n   * Check if a wildcard pattern matches an event name\n   * @param {string} pattern - The wildcard pattern to check\n   * @param {string} eventName - The event name to match against\n   * @return {boolean} - True if the pattern matches the event name\n   * @private\n   */\n  _matchesWildcard(pattern, eventName) {\n    // Single-level wildcard (*)\n    if (pattern.includes('*') && !pattern.includes('**')) {\n      const regex = new RegExp('^' + pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '[^.]+') + '$');\n      return regex.test(eventName);\n    }\n    \n    // Multi-level wildcard (**)\n    if (pattern.includes('**')) {\n      const regex = new RegExp('^' + pattern.replace(/\\./g, '\\\\.').replace(/\\*\\*/g, '.*').replace(/\\*/g, '[^.]+') + '$');\n      return regex.test(eventName);\n    }\n    \n    return false;\n  }\n}\n\nmodule.exports = EventSystem;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,WAAW,CAAC;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxB;IACA,IAAI,CAACA,OAAO,GAAG;MACbC,gBAAgB,EAAE,IAAI;MACtBC,SAAS,EAAE,KAAK;MAChBC,eAAe,EAAE,KAAK;MACtBC,YAAY,EAAE,GAAG;MACjB,GAAGJ;IACL,CAAC;;IAED;IACA,IAAI,CAACK,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;;IAE1B;IACA,IAAI,CAACC,YAAY,GAAG,EAAE;;IAEtB;IACA,IAAI,CAACC,SAAS,GAAG,KAAK;;IAEtB;IACA,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,gBAAgB,GAAG,EAAE;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,EAAEA,CAACC,SAAS,EAAEC,QAAQ,EAAEC,QAAQ,GAAG,CAAC,EAAE;IACpC;IACA,IAAI,OAAOF,SAAS,KAAK,QAAQ,IAAIA,SAAS,CAACG,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MAC5D,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IAEA,IAAI,OAAOH,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAIG,KAAK,CAAC,6BAA6B,CAAC;IAChD;;IAEA;IACA,IAAI,IAAI,CAACR,SAAS,EAAE;MAClB,IAAI,CAACC,iBAAiB,CAACQ,IAAI,CAAC;QAAEL,SAAS;QAAEC,QAAQ;QAAEC,QAAQ;QAAEI,IAAI,EAAE;MAAM,CAAC,CAAC;MAC3E,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,CAAC,IAAI,CAACb,SAAS,CAACc,GAAG,CAACP,SAAS,CAAC,EAAE;MAClC,IAAI,CAACP,SAAS,CAACe,GAAG,CAACR,SAAS,EAAE,EAAE,CAAC;IACnC;IAEA,MAAMP,SAAS,GAAG,IAAI,CAACA,SAAS,CAACgB,GAAG,CAACT,SAAS,CAAC;;IAE/C;IACA,MAAMU,aAAa,GAAGjB,SAAS,CAACkB,SAAS,CAACC,QAAQ,IAAIA,QAAQ,CAACX,QAAQ,KAAKA,QAAQ,CAAC;IACrF,IAAIS,aAAa,KAAK,CAAC,CAAC,EAAE;MACxB;MACAjB,SAAS,CAACiB,aAAa,CAAC,CAACR,QAAQ,GAAGA,QAAQ;IAC9C,CAAC,MAAM;MACL;MACAT,SAAS,CAACY,IAAI,CAAC;QAAEJ,QAAQ;QAAEK,IAAI,EAAE,KAAK;QAAEJ;MAAS,CAAC,CAAC;;MAEnD;MACAT,SAAS,CAACoB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACb,QAAQ,GAAGY,CAAC,CAACZ,QAAQ,CAAC;IACnD;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,IAAIA,CAACN,SAAS,EAAEC,QAAQ,EAAEC,QAAQ,GAAG,CAAC,EAAE;IACtC;IACA,IAAI,OAAOF,SAAS,KAAK,QAAQ,IAAIA,SAAS,CAACG,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MAC5D,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IAEA,IAAI,OAAOH,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAIG,KAAK,CAAC,6BAA6B,CAAC;IAChD;;IAEA;IACA,IAAI,IAAI,CAACR,SAAS,EAAE;MAClB,IAAI,CAACC,iBAAiB,CAACQ,IAAI,CAAC;QAAEL,SAAS;QAAEC,QAAQ;QAAEC,QAAQ;QAAEI,IAAI,EAAE;MAAK,CAAC,CAAC;MAC1E,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,CAAC,IAAI,CAACb,SAAS,CAACc,GAAG,CAACP,SAAS,CAAC,EAAE;MAClC,IAAI,CAACP,SAAS,CAACe,GAAG,CAACR,SAAS,EAAE,EAAE,CAAC;IACnC;IAEA,MAAMP,SAAS,GAAG,IAAI,CAACA,SAAS,CAACgB,GAAG,CAACT,SAAS,CAAC;;IAE/C;IACA,MAAMU,aAAa,GAAGjB,SAAS,CAACkB,SAAS,CAACC,QAAQ,IAAIA,QAAQ,CAACX,QAAQ,KAAKA,QAAQ,CAAC;IACrF,IAAIS,aAAa,KAAK,CAAC,CAAC,EAAE;MACxB;MACAjB,SAAS,CAACiB,aAAa,CAAC,CAACR,QAAQ,GAAGA,QAAQ;MAC5CT,SAAS,CAACiB,aAAa,CAAC,CAACJ,IAAI,GAAG,IAAI;IACtC,CAAC,MAAM;MACL;MACAb,SAAS,CAACY,IAAI,CAAC;QAAEJ,QAAQ;QAAEK,IAAI,EAAE,IAAI;QAAEJ;MAAS,CAAC,CAAC;;MAElD;MACAT,SAAS,CAACoB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACb,QAAQ,GAAGY,CAAC,CAACZ,QAAQ,CAAC;IACnD;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEc,GAAGA,CAAChB,SAAS,EAAEC,QAAQ,GAAG,IAAI,EAAE;IAC9B;IACA,IAAI,IAAI,CAACL,SAAS,EAAE;MAClB,IAAI,CAACE,gBAAgB,CAACO,IAAI,CAAC;QAAEL,SAAS;QAAEC;MAAS,CAAC,CAAC;MACnD,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,CAAC,IAAI,CAACR,SAAS,CAACc,GAAG,CAACP,SAAS,CAAC,EAAE;MAClC,OAAO,IAAI;IACb;;IAEA;IACA,IAAIC,QAAQ,KAAK,IAAI,EAAE;MACrB,IAAI,CAACR,SAAS,CAACwB,MAAM,CAACjB,SAAS,CAAC;MAChC,OAAO,IAAI;IACb;;IAEA;IACA,MAAMP,SAAS,GAAG,IAAI,CAACA,SAAS,CAACgB,GAAG,CAACT,SAAS,CAAC;IAC/C,MAAMkB,iBAAiB,GAAGzB,SAAS,CAAC0B,MAAM,CAACP,QAAQ,IAAIA,QAAQ,CAACX,QAAQ,KAAKA,QAAQ,CAAC;IAEtF,IAAIiB,iBAAiB,CAACE,MAAM,KAAK,CAAC,EAAE;MAClC;MACA,IAAI,CAAC3B,SAAS,CAACwB,MAAM,CAACjB,SAAS,CAAC;IAClC,CAAC,MAAM;MACL;MACA,IAAI,CAACP,SAAS,CAACe,GAAG,CAACR,SAAS,EAAEkB,iBAAiB,CAAC;IAClD;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,IAAIA,CAACrB,SAAS,EAAEsB,IAAI,EAAE;IACpB;IACA,MAAMC,WAAW,GAAG,IAAI,CAAC3B,SAAS;IAClC,IAAI,CAACA,SAAS,GAAG,IAAI;;IAErB;IACA,IAAI4B,eAAe,GAAG,KAAK;IAE3B,IAAI;MACF;MACA,IAAI,IAAI,CAACpC,OAAO,CAACE,SAAS,EAAE;QAC1B,IAAI,CAACmC,aAAa,CAACzB,SAAS,EAAEsB,IAAI,CAAC;MACrC;;MAEA;MACA,MAAMI,gBAAgB,GAAG,IAAI,CAACC,yBAAyB,CAAC3B,SAAS,CAAC;;MAElE;MACA,KAAK,MAAM4B,IAAI,IAAIF,gBAAgB,EAAE;QACnC,IAAI,IAAI,CAACjC,SAAS,CAACc,GAAG,CAACqB,IAAI,CAAC,EAAE;UAC5B,MAAMnC,SAAS,GAAG,IAAI,CAACA,SAAS,CAACgB,GAAG,CAACmB,IAAI,CAAC;UAC1C,MAAMC,iBAAiB,GAAG,EAAE;;UAE5B;UACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrC,SAAS,CAAC2B,MAAM,EAAEU,CAAC,EAAE,EAAE;YACzC,MAAM;cAAE7B,QAAQ;cAAEK;YAAK,CAAC,GAAGb,SAAS,CAACqC,CAAC,CAAC;YAEvC,IAAI;cACF;cACA7B,QAAQ,CAACqB,IAAI,CAAC;cACdE,eAAe,GAAG,IAAI;;cAEtB;cACA,IAAIlB,IAAI,EAAE;gBACRuB,iBAAiB,CAACxB,IAAI,CAACJ,QAAQ,CAAC;cAClC;YACF,CAAC,CAAC,OAAO8B,KAAK,EAAE;cACd;cACAC,OAAO,CAACD,KAAK,CAAC,gCAAgCH,IAAI,IAAI,EAAEG,KAAK,CAAC;YAChE;UACF;;UAEA;UACA,IAAI,CAACR,WAAW,EAAE;YAChB,KAAK,MAAMtB,QAAQ,IAAI4B,iBAAiB,EAAE;cACxC,IAAI,CAACb,GAAG,CAACY,IAAI,EAAE3B,QAAQ,CAAC;YAC1B;UACF;QACF;MACF;;MAEA;MACA,IAAI,CAACsB,WAAW,EAAE;QAChB,IAAI,CAACU,yBAAyB,CAAC,CAAC;MAClC;MAEA,OAAOT,eAAe;IACxB,CAAC,SAAS;MACR;MACA,IAAI,CAACD,WAAW,EAAE;QAChB,IAAI,CAAC3B,SAAS,GAAG,KAAK;MACxB;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEsC,YAAYA,CAAClC,SAAS,EAAE;IACtB;IACA,IAAI,IAAI,CAACP,SAAS,CAACc,GAAG,CAACP,SAAS,CAAC,IAAI,IAAI,CAACP,SAAS,CAACgB,GAAG,CAACT,SAAS,CAAC,CAACoB,MAAM,GAAG,CAAC,EAAE;MAC7E,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,IAAI,CAAChC,OAAO,CAACG,eAAe,EAAE;MAChC,KAAK,MAAM,CAACqC,IAAI,EAAEnC,SAAS,CAAC,IAAI,IAAI,CAACA,SAAS,CAAC0C,OAAO,CAAC,CAAC,EAAE;QACxD,IAAI1C,SAAS,CAAC2B,MAAM,GAAG,CAAC,IAAI,IAAI,CAACgB,gBAAgB,CAACR,IAAI,EAAE5B,SAAS,CAAC,EAAE;UAClE,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACEqC,aAAaA,CAACrC,SAAS,EAAE;IACvB,IAAIsC,KAAK,GAAG,CAAC;;IAEb;IACA,IAAI,IAAI,CAAC7C,SAAS,CAACc,GAAG,CAACP,SAAS,CAAC,EAAE;MACjCsC,KAAK,IAAI,IAAI,CAAC7C,SAAS,CAACgB,GAAG,CAACT,SAAS,CAAC,CAACoB,MAAM;IAC/C;;IAEA;IACA,IAAI,IAAI,CAAChC,OAAO,CAACG,eAAe,EAAE;MAChC,KAAK,MAAM,CAACqC,IAAI,EAAEnC,SAAS,CAAC,IAAI,IAAI,CAACA,SAAS,CAAC0C,OAAO,CAAC,CAAC,EAAE;QACxD,IAAIP,IAAI,KAAK5B,SAAS,IAAI,IAAI,CAACoC,gBAAgB,CAACR,IAAI,EAAE5B,SAAS,CAAC,EAAE;UAChEsC,KAAK,IAAI7C,SAAS,CAAC2B,MAAM;QAC3B;MACF;IACF;IAEA,OAAOkB,KAAK;EACd;;EAEA;AACF;AACA;AACA;EACEC,UAAUA,CAAA,EAAG;IACX,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAChD,SAAS,CAACiD,IAAI,CAAC,CAAC,CAAC;EAC1C;;EAEA;AACF;AACA;AACA;AACA;EACEC,eAAeA,CAACC,KAAK,GAAG,EAAE,EAAE;IAC1B,IAAI,CAAC,IAAI,CAACxD,OAAO,CAACE,SAAS,EAAE;MAC3B,OAAO,EAAE;IACX;IAEA,MAAMuD,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACH,KAAK,EAAE,IAAI,CAACjD,YAAY,CAACyB,MAAM,CAAC;IAC7D,OAAO,IAAI,CAACzB,YAAY,CAACqD,KAAK,CAAC,CAACH,WAAW,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;EACEI,kBAAkBA,CAAA,EAAG;IACnB,IAAI,CAACxD,SAAS,CAACyD,KAAK,CAAC,CAAC;IACtB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACEjB,yBAAyBA,CAAA,EAAG;IAC1B;IACA,KAAK,MAAM;MAAEjC,SAAS;MAAEC;IAAS,CAAC,IAAI,IAAI,CAACH,gBAAgB,EAAE;MAC3D,IAAI,CAACkB,GAAG,CAAChB,SAAS,EAAEC,QAAQ,CAAC;IAC/B;IACA,IAAI,CAACH,gBAAgB,GAAG,EAAE;;IAE1B;IACA,KAAK,MAAM;MAAEE,SAAS;MAAEC,QAAQ;MAAEC,QAAQ;MAAEI;IAAK,CAAC,IAAI,IAAI,CAACT,iBAAiB,EAAE;MAC5E,IAAIS,IAAI,EAAE;QACR,IAAI,CAACA,IAAI,CAACN,SAAS,EAAEC,QAAQ,EAAEC,QAAQ,CAAC;MAC1C,CAAC,MAAM;QACL,IAAI,CAACH,EAAE,CAACC,SAAS,EAAEC,QAAQ,EAAEC,QAAQ,CAAC;MACxC;IACF;IACA,IAAI,CAACL,iBAAiB,GAAG,EAAE;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE4B,aAAaA,CAACzB,SAAS,EAAEsB,IAAI,EAAE;IAC7B;IACA,IAAI,CAAC3B,YAAY,CAACU,IAAI,CAAC;MACrBL,SAAS;MACTsB,IAAI;MACJ6B,SAAS,EAAE,IAAIC,IAAI,CAAC;IACtB,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAACzD,YAAY,CAACyB,MAAM,GAAG,IAAI,CAAChC,OAAO,CAACI,YAAY,EAAE;MACxD,IAAI,CAACG,YAAY,CAAC0D,KAAK,CAAC,CAAC;IAC3B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE1B,yBAAyBA,CAAC3B,SAAS,EAAE;IACnC,MAAMuC,UAAU,GAAG,CAACvC,SAAS,CAAC;;IAE9B;IACA,IAAI,IAAI,CAACZ,OAAO,CAACC,gBAAgB,IAAIW,SAAS,CAACsD,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC5D,MAAMC,KAAK,GAAGvD,SAAS,CAACwD,KAAK,CAAC,GAAG,CAAC;MAClC,KAAK,IAAI1B,CAAC,GAAGyB,KAAK,CAACnC,MAAM,GAAG,CAAC,EAAEU,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACzCS,UAAU,CAAClC,IAAI,CAACkD,KAAK,CAACP,KAAK,CAAC,CAAC,EAAElB,CAAC,CAAC,CAAC2B,IAAI,CAAC,GAAG,CAAC,CAAC;MAC9C;IACF;;IAEA;IACA,IAAI,IAAI,CAACrE,OAAO,CAACG,eAAe,EAAE;MAChC,KAAK,MAAMqC,IAAI,IAAI,IAAI,CAACnC,SAAS,CAACiD,IAAI,CAAC,CAAC,EAAE;QACxC,IAAI,CAACH,UAAU,CAACe,QAAQ,CAAC1B,IAAI,CAAC,IAAI,IAAI,CAACQ,gBAAgB,CAACR,IAAI,EAAE5B,SAAS,CAAC,EAAE;UACxEuC,UAAU,CAAClC,IAAI,CAACuB,IAAI,CAAC;QACvB;MACF;IACF;IAEA,OAAOW,UAAU;EACnB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEH,gBAAgBA,CAACsB,OAAO,EAAE1D,SAAS,EAAE;IACnC;IACA,IAAI0D,OAAO,CAACJ,QAAQ,CAAC,GAAG,CAAC,IAAI,CAACI,OAAO,CAACJ,QAAQ,CAAC,IAAI,CAAC,EAAE;MACpD,MAAMK,KAAK,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGF,OAAO,CAACG,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,GAAG,CAAC;MAC3F,OAAOF,KAAK,CAACG,IAAI,CAAC9D,SAAS,CAAC;IAC9B;;IAEA;IACA,IAAI0D,OAAO,CAACJ,QAAQ,CAAC,IAAI,CAAC,EAAE;MAC1B,MAAMK,KAAK,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGF,OAAO,CAACG,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAACA,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,GAAG,CAAC;MAClH,OAAOF,KAAK,CAACG,IAAI,CAAC9D,SAAS,CAAC;IAC9B;IAEA,OAAO,KAAK;EACd;AACF;AAEA+D,MAAM,CAACC,OAAO,GAAG9E,WAAW","ignoreList":[]}