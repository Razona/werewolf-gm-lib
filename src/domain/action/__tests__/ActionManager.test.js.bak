/**
 * ActionManager クラスのテスト
 * 人狼ゲームのアクション処理を管理するマネージャークラスのテスト
 *
 * このテストでは、アクションの登録・実行・結果取得などの基本機能から、
 * 役職間の複雑な相互作用やレギュレーション対応まで検証します。
 */


import Action from '../Action';
import EventSystem from '../../../core/event/EventSystem';
import ErrorHandler from '../../../core/error/ErrorHandler';

// テスト用のモック
jest.mock('../../../core/event/EventSystem');
jest.mock('../../../core/error/ErrorHandler');

describe('ActionManager', () => {
  // テスト用モックと変数
  let actionManager;
  let mockEventSystem;
  let mockErrorHandler;
  let mockPlayerManager;
  let mockRoleManager;
  let mockPhaseManager;
  let mockGame;

  // テスト用プレイヤーデータの初期定義
  const initialTestPlayers = {
    // 占い師プレイヤー
    seer: {
      id: 1,
      name: '占い師プレイヤー',
      isAlive: true,
      role: { name: 'seer', team: 'village' }
    },
    // 騎士プレイヤー
    knight: {
      id: 2,
      name: '騎士プレイヤー',
      isAlive: true,
      role: { name: 'knight', team: 'village' }
    },
    // 人狼プレイヤー
    werewolf: {
      id: 3,
      name: '人狼プレイヤー',
      isAlive: true,
      role: { name: 'werewolf', team: 'werewolf' }
    },
    // 村人プレイヤー
    villager: {
      id: 4,
      name: '村人プレイヤー',
      isAlive: true,
      isGuarded: false,
      role: { name: 'villager', team: 'village' }
    },
    // 妖狐プレイヤー
    fox: {
      id: 5,
      name: '妖狐プレイヤー',
      isAlive: true,
      role: { name: 'fox', team: 'fox' }
    }
  };

  // 各テストで使用するプレイヤーデータ
  let testPlayers;

  // テスト用役職データ
  const roleDefinitions = {
    seer: {
      name: 'seer',
      team: 'village',
      actionTypes: ['fortune'],
      fortuneResult: 'white',
      mediumResult: 'white'
    },
    knight: {
      name: 'knight',
      team: 'village',
      actionTypes: ['guard'],
      fortuneResult: 'white',
      mediumResult: 'white'
    },
    werewolf: {
      name: 'werewolf',
      team: 'werewolf',
      actionTypes: ['attack'],
      fortuneResult: 'black',
      mediumResult: 'black'
    },
    villager: {
      name: 'villager',
      team: 'village',
      actionTypes: [],
      fortuneResult: 'white',
      mediumResult: 'white'
    },
    fox: {
      name: 'fox',
      team: 'fox',
      actionTypes: [],
      fortuneResult: 'white',
      mediumResult: 'white',
      // 特殊能力：襲撃耐性、占い師による呪殺効果
      isImmuneToDeath: { attack: true },
      isVulnerableTo: { fortune: true }
    }
  };

  // レギュレーション設定
  const regulations = {
    allowConsecutiveGuard: false,
    firstNightFortune: 'free'
  };

  // ActionManagerクラスモックの作成
  function createActionManager() {
    // ActionManagerクラスの作成
    const ActionManager = function (game) {
      this.game = game;
      this.actions = [];
      this.lastGuardedTarget = null;
      this.actionResults = new Map();
    };

    // アクション登録メソッド
    ActionManager.prototype.registerAction = function (actionData) {
      // プレイヤーの存在確認
      const actor = this.game.playerManager.getPlayer(actionData.actor);
      if (!actor) {
        throw this.game.errorHandler.createError(
          'E3002_INVALID_PLAYER',
          `プレイヤーID ${actionData.actor} は存在しません`
        );
      }

      const target = this.game.playerManager.getPlayer(actionData.target);
      if (!target) {
        throw this.game.errorHandler.createError(
          'E3002_INVALID_PLAYER',
          `対象プレイヤーID ${actionData.target} は存在しません`
        );
      }

      // プレイヤーの生存確認
      if (!actor.isAlive) {
        throw this.game.errorHandler.createError(
          'E3003_UNAUTHORIZED_ACTION',
          `プレイヤー ${actor.name} は死亡しているためアクションを実行できません`
        );
      }

      // アクション種別の確認
      if (!['fortune', 'guard', 'attack'].includes(actionData.type)) {
        throw this.game.errorHandler.createError(
          'E3001_INVALID_ACTION_TYPE',
          `不正なアクション種別です: ${actionData.type}`
        );
      }

      // 役職とアクション種別の権限チェック
      const canUseAction = this.game.roleManager.canUseAction(actor.id, actionData.type);
      if (!canUseAction) {
        throw this.game.errorHandler.createError(
          'E3003_UNAUTHORIZED_ACTION',
          `プレイヤー ${actor.name} はアクション ${actionData.type} を実行する権限がありません`
        );
      }

      // 連続ガード禁止チェック
      if (actionData.type === 'guard' &&
        this.game.regulations.allowConsecutiveGuard === false &&
        this.lastGuardedTarget === actionData.target) {
        throw this.game.errorHandler.createError(
          'E3005_CONSECUTIVE_GUARD_PROHIBITED',
          '同一対象への連続護衛は禁止されています'
        );
      }

      // アクションオブジェクトの作成
      const action = new Action(actionData);
      action.setGame(this.game);

      // アクションを登録
      this.actions.push(action);

      // イベント発火
      this.game.eventSystem.emit('action.register', {
        id: action.id,
        type: action.type,
        actor: action.actor,
        target: action.target,
        night: action.night
      });

      return action;
    };

    // アクション実行メソッド
    ActionManager.prototype.executeAction = function (action) {
      if (!action.isExecutable()) {
        return { success: false, reason: 'NOT_EXECUTABLE' };
      }

      const result = action.execute();
      return result;
    };

    // 複数アクション実行メソッド
    ActionManager.prototype.executeActions = function (phase, turn) {
      // 指定されたフェーズとターンのアクションをフィルタリング
      const actionsToExecute = this.actions.filter(
        action => action.isExecutable() && action.night === turn
      );

      // 優先度順にソート（高い順）
      actionsToExecute.sort((a, b) => b.priority - a.priority);

      // 各アクションを実行
      for (const action of actionsToExecute) {
        this.executeAction(action);
      }

      // 完了イベント発火
      this.game.eventSystem.emit('action.execute.complete', {
        phase,
        turn,
        executedCount: actionsToExecute.length
      });

      return actionsToExecute.length;
    };

    // アクション結果取得メソッド
    ActionManager.prototype.getActionResults = function (playerId) {
      return this.actions
        .filter(action => action.actor === playerId)
        .map(action => ({
          id: action.id,
          type: action.type,
          actor: action.actor,
          target: action.target,
          night: action.night,
          result: action.result
        }));
    };

    return new ActionManager(mockGame);
  }

  // テスト前のセットアップ
  beforeEach(() => {
    // テスト用プレイヤーデータを初期化
    testPlayers = JSON.parse(JSON.stringify(initialTestPlayers));

    // イベントシステムのモック
    mockEventSystem = {
      emit: jest.fn(),
      on: jest.fn()
    };

    // エラーハンドラーのモック
    mockErrorHandler = {
      createError: jest.fn((code, message) => {
        const error = new Error(message);
        error.code = code;
        return error;
      }),
      handleError: jest.fn()
    };

    // プレイヤーマネージャーのモック
    mockPlayerManager = {
      getPlayer: jest.fn(id => {
        // テストプレイヤーデータから対応するプレイヤーを返す
        const player = Object.values(testPlayers).find(p => p.id === id);
        return player || null;
      }),
      getAlivePlayers: jest.fn(() => {
        // 生存プレイヤーのみ返す
        return Object.values(testPlayers).filter(p => p.isAlive);
      }),
      killPlayer: jest.fn((playerId, cause) => {
        // プレイヤーの死亡処理をシミュレート
        const player = Object.values(testPlayers).find(p => p.id === playerId);
        if (player) {
          player.isAlive = false;
          player.causeOfDeath = cause;
          return true;
        }
        return false;
      })
    };

    // ロールマネージャーのモック
    mockRoleManager = {
      getRole: jest.fn(roleName => {
        // テスト役職データから対応する役職を返す
        return roleDefinitions[roleName] || null;
      }),
      canUseAction: jest.fn((playerId, actionType) => {
        // プレイヤーが特定のアクション種別を使用できるかチェック
        const player = mockPlayerManager.getPlayer(playerId);
        if (!player || !player.isAlive) return false;

        const role = mockRoleManager.getRole(player.role.name);
        return role && role.actionTypes && role.actionTypes.includes(actionType);
      })
    };

    // フェーズマネージャーのモック
    mockPhaseManager = {
      getCurrentPhase: jest.fn(() => 'night'),
      getCurrentTurn: jest.fn(() => 1)
    };

    // ゲームオブジェクトのモック
    mockGame = {
      eventSystem: mockEventSystem,
      errorHandler: mockErrorHandler,
      playerManager: mockPlayerManager,
      roleManager: mockRoleManager,
      phaseManager: mockPhaseManager,
      regulations,
      // ゲームイベント発火のヘルパーメソッド
      emit: function (eventName, data) {
        return this.eventSystem.emit(eventName, data);
      }
    };

    // ActionManagerの初期化
    actionManager = createActionManager();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  /**
   * アクション登録のテスト
   */
  describe('アクション登録', () => {
    test('有効なアクションを正常に登録すべき', () => {
      // 準備: 有効なアクションデータを作成
      const actionData = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // 実行: アクションを登録
      const registeredAction = actionManager.registerAction(actionData);

      // 検証: 登録されたアクションが正しいこと
      expect(registeredAction).toBeDefined();
      expect(registeredAction.id).toBeTruthy();
      expect(registeredAction.type).toBe('fortune');
      expect(registeredAction.actor).toBe(testPlayers.seer.id);
      expect(registeredAction.target).toBe(testPlayers.villager.id);
      expect(registeredAction.night).toBe(1);
    });

    test('不正なプレイヤーIDでアクション登録時にエラーとなるべき', () => {
      const actionData = {
        type: 'fortune',
        actor: 999, // 存在しないプレイヤーID
        target: testPlayers.villager.id,
        night: 1
      };

      expect(() => {
        actionManager.registerAction(actionData);
      }).toThrow();

      expect(mockErrorHandler.createError).toHaveBeenCalledWith(
        'E3002_INVALID_PLAYER',
        expect.any(String)
      );
    });

    test('不正なアクション種別で登録するとエラーとなるべき', () => {
      const actionData = {
        type: 'invalid_action',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      expect(() => {
        actionManager.registerAction(actionData);
      }).toThrow();

      expect(mockErrorHandler.createError).toHaveBeenCalledWith(
        'E3001_INVALID_ACTION_TYPE',
        expect.any(String)
      );
    });

    test('死亡プレイヤーによるアクション登録はエラーとなるべき', () => {
      // プレイヤーを死亡状態に設定
      testPlayers.seer.isAlive = false;

      const actionData = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      expect(() => {
        actionManager.registerAction(actionData);
      }).toThrow();

      expect(mockErrorHandler.createError).toHaveBeenCalledWith(
        'E3003_UNAUTHORIZED_ACTION',
        expect.any(String)
      );
    });

    test('権限のないプレイヤーのアクション登録はエラーとなるべき', () => {
      const actionData = {
        type: 'fortune', // 占いアクション
        actor: testPlayers.villager.id, // 村人（占い権限なし）
        target: testPlayers.werewolf.id,
        night: 1
      };

      expect(() => {
        actionManager.registerAction(actionData);
      }).toThrow();

      expect(mockErrorHandler.createError).toHaveBeenCalledWith(
        'E3003_UNAUTHORIZED_ACTION',
        expect.any(String)
      );
    });

    test('アクション登録時にイベントが発火されるべき', () => {
      const actionData = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      actionManager.registerAction(actionData);

      expect(mockEventSystem.emit).toHaveBeenCalledWith('action.register', expect.objectContaining({
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id
      }));
    });
  });

  /**
   * アクション実行のテスト
   */
  describe('アクション実行', () => {
    test('登録されたアクションが優先度順に実行されるべき', () => {
      // 優先度の異なるアクション登録（低い優先度から順に）
      const actions = [
        {
          type: 'attack',
          actor: testPlayers.werewolf.id,
          target: testPlayers.villager.id,
          night: 1,
          priority: 60
        },
        {
          type: 'guard',
          actor: testPlayers.knight.id,
          target: testPlayers.villager.id,
          night: 1,
          priority: 80
        },
        {
          type: 'fortune',
          actor: testPlayers.seer.id,
          target: testPlayers.werewolf.id,
          night: 1,
          priority: 100
        }
      ];

      // アクションを登録
      actions.forEach(action => actionManager.registerAction(action));

      // 実行順序を記録するためのモック
      const executionOrder = [];
      jest.spyOn(actionManager, 'executeAction').mockImplementation((action) => {
        executionOrder.push(action.type);
        return { success: true };
      });

      // アクション実行
      actionManager.executeActions('night', 1);

      // 優先度の高い順（fortune → guard → attack）に実行されることを確認
      expect(executionOrder).toEqual(['fortune', 'guard', 'attack']);
    });

    test('特定のフェーズとターンのアクションのみ実行されるべき', () => {
      // 異なるターンのアクション登録
      const actions = [
        {
          type: 'fortune',
          actor: testPlayers.seer.id,
          target: testPlayers.werewolf.id,
          night: 1
        },
        {
          type: 'fortune',
          actor: testPlayers.seer.id,
          target: testPlayers.villager.id,
          night: 2
        }
      ];

      // アクションを登録
      actions.forEach(action => actionManager.registerAction(action));

      // 実行されたアクションを記録するためのモック
      const executedActions = [];
      jest.spyOn(actionManager, 'executeAction').mockImplementation((action) => {
        executedActions.push(action);
        return { success: true };
      });

      // ターン1のアクションを実行
      actionManager.executeActions('night', 1);

      // ターン1のアクションのみが実行されたことを確認
      expect(executedActions.length).toBe(1);
      expect(executedActions[0].night).toBe(1);
      expect(executedActions[0].target).toBe(testPlayers.werewolf.id);
    });

    test('すべてのアクション実行完了後にイベントが発火されるべき', () => {
      const action = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.werewolf.id,
        night: 1
      };

      // アクションを登録
      actionManager.registerAction(action);

      // 実行関数をモック
      jest.spyOn(actionManager, 'executeAction').mockImplementation(() => {
        return { success: true };
      });

      // アクション実行
      actionManager.executeActions('night', 1);

      // 完了イベントが発火されたことを確認
      expect(mockEventSystem.emit).toHaveBeenCalledWith('action.execute.complete', expect.objectContaining({
        phase: 'night',
        turn: 1
      }));
    });
  });

  /**
   * アクション結果取得のテスト
   */
  describe('アクション結果取得', () => {
    test('プレイヤーIDに基づいて自分のアクション結果のみが取得できるべき', () => {
      // 異なるプレイヤーによるアクション登録
      const actions = [
        {
          type: 'fortune',
          actor: testPlayers.seer.id,
          target: testPlayers.werewolf.id,
          night: 1
        },
        {
          type: 'guard',
          actor: testPlayers.knight.id,
          target: testPlayers.villager.id,
          night: 1
        }
      ];

      // アクションを登録
      const registeredActions = actions.map(action => actionManager.registerAction(action));

      // 結果をセット
      registeredActions[0].result = { success: true, result: 'black' };
      registeredActions[1].result = { success: true, guarded: true };

      // 占い師のアクション結果のみを取得
      const seerResults = actionManager.getActionResults(testPlayers.seer.id);

      // 占い師のアクション結果のみが含まれることを確認
      expect(seerResults.length).toBe(1);
      expect(seerResults[0].type).toBe('fortune');
      expect(seerResults[0].result.result).toBe('black');

      // 騎士のアクション結果は含まれていないことを確認
      const hasKnightResult = seerResults.some(r => r.actor === testPlayers.knight.id);
      expect(hasKnightResult).toBe(false);
    });

    test('実行されていないアクションの結果はnullであるべき', () => {
      // アクションを登録
      const action = actionManager.registerAction({
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.werewolf.id,
        night: 1
      });

      // 結果を取得
      const results = actionManager.getActionResults(testPlayers.seer.id);

      // 未実行のアクションの結果はnullであることを確認
      expect(results[0].result).toBeNull();
    });
  });

  /**
   * レギュレーション対応のテスト
   */
  describe('レギュレーション対応', () => {
    test('連続ガード禁止が有効な場合、同一対象への連続護衛はエラーとなるべき', () => {
      // レギュレーションで連続ガード禁止を設定
      regulations.allowConsecutiveGuard = false;

      // 1ターン目の護衛アクション
      const firstGuardAction = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // アクションを登録
      actionManager.registerAction(firstGuardAction);

      // 前回の護衛対象を記録（通常はアクション実行時に設定されるが、テストのため手動で設定）
      actionManager.lastGuardedTarget = testPlayers.villager.id;

      // 2ターン目の同一対象への護衛アクション
      const secondGuardAction = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 2
      };

      // 2ターン目に設定
      mockPhaseManager.getCurrentTurn.mockReturnValueOnce(2);

      // エラーが発生することを確認
      expect(() => {
        actionManager.registerAction(secondGuardAction);
      }).toThrow();

      expect(mockErrorHandler.createError).toHaveBeenCalledWith(
        'E3005_CONSECUTIVE_GUARD_PROHIBITED',
        expect.any(String)
      );
    });

    test('連続ガード禁止が無効な場合、同一対象への連続護衛が可能であるべき', () => {
      // レギュレーションで連続ガード禁止を無効化
      regulations.allowConsecutiveGuard = true;

      // 1ターン目の護衛アクション
      const firstGuardAction = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // アクションを登録
      actionManager.registerAction(firstGuardAction);

      // 前回の護衛対象を記録
      actionManager.lastGuardedTarget = testPlayers.villager.id;

      // 2ターン目の同一対象への護衛アクション
      const secondGuardAction = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 2
      };

      // 2ターン目に設定
      mockPhaseManager.getCurrentTurn.mockReturnValueOnce(2);

      // エラーが発生しないこと（連続護衛が可能）を確認
      expect(() => {
        actionManager.registerAction(secondGuardAction);
      }).not.toThrow();
    });
  });

  /**
   * 特殊な相互作用のテスト
   */
  describe('特殊な相互作用', () => {
    test('護衛されたプレイヤーは襲撃から生存するべき', () => {
      // モック関数を再定義して結果を確認できるようにする
      actionManager.executeAction = jest.fn(action => {
        // Action.executeの振る舞いをシミュレート
        let result = { success: true };

        // 護衛アクションの場合
        if (action.type === 'guard') {
          const target = mockPlayerManager.getPlayer(action.target);
          // 護衛状態をシミュレート
          target.isGuarded = true;
          result = { success: true, guarded: true };
        }
        // 襲撃アクションの場合
        else if (action.type === 'attack') {
          const target = mockPlayerManager.getPlayer(action.target);
          // 護衛されている場合
          if (target.isGuarded) {
            result = { success: true, killed: false, reason: 'GUARDED' };
          } else {
            // 護衛されていない場合は死亡
            mockPlayerManager.killPlayer(target.id, 'attack');
            result = { success: true, killed: true };
          }
        }

        // 結果を設定
        action.result = result;
        return result;
      });

      // 1. 護衛アクション
      const guardAction = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 1,
        priority: 80
      };

      // 2. 襲撃アクション
      const attackAction = {
        type: 'attack',
        actor: testPlayers.werewolf.id,
        target: testPlayers.villager.id,
        night: 1,
        priority: 60
      };

      // アクションを登録
      actionManager.registerAction(guardAction);
      actionManager.registerAction(attackAction);

      // アクション実行
      actionManager.executeActions('night', 1);

      // 村人が生存していることを確認
      expect(testPlayers.villager.isAlive).toBe(true);
    });

    test('妖狐は襲撃耐性を持つべき', () => {
      // モック関数を再定義して結果を確認できるようにする
      actionManager.executeAction = jest.fn(action => {
        // Action.executeの振る舞いをシミュレート
        let result = { success: true };

        // 襲撃アクションの場合
        if (action.type === 'attack') {
          const target = mockPlayerManager.getPlayer(action.target);
          // 妖狐の場合（襲撃耐性あり）
          if (target.role.name === 'fox') {
            result = { success: true, killed: false, reason: 'RESISTANT' };
          } else {
            // 通常のプレイヤーは死亡
            mockPlayerManager.killPlayer(target.id, 'attack');
            result = { success: true, killed: true };
          }
        }

        // 結果を設定
        action.result = result;
        return result;
      });

      // 妖狐への襲撃アクション
      const attackFoxAction = {
        type: 'attack',
        actor: testPlayers.werewolf.id,
        target: testPlayers.fox.id,
        night: 1
      };

      // 村人への襲撃アクション
      const attackVillagerAction = {
        type: 'attack',
        actor: testPlayers.werewolf.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // アクションを登録
      const foxAttack = actionManager.registerAction(attackFoxAction);
      const villagerAttack = actionManager.registerAction(attackVillagerAction);

      // アクション実行
      actionManager.executeActions('night', 1);

      // 妖狐が生存していることを確認
      expect(testPlayers.fox.isAlive).toBe(true);
      expect(foxAttack.result.killed).toBe(false);
      expect(foxAttack.result.reason).toBe('RESISTANT');

      // 村人は死亡していることを確認
      expect(testPlayers.villager.isAlive).toBe(false);
      expect(villagerAttack.result.killed).toBe(true);
    });

    test('妖狐への占いで呪殺効果が発生するべき', () => {
      // モック関数を再定義して結果を確認できるようにする
      actionManager.executeAction = jest.actionManager.executeAction = jest.fn(action => {
        // Action.executeの振る舞いをシミュレート
        let result = { success: true };

        // 占いアクションの場合
        if (action.type === 'fortune') {
          const target = mockPlayerManager.getPlayer(action.target);
          // 占い結果をシミュレート
          let fortuneResult = 'white'; // デフォルトは白判定

          // 人狼の場合は黒判定
          if (target.role.name === 'werewolf') {
            fortuneResult = 'black';
          }

          result = { success: true, result: fortuneResult };

          // 妖狐の場合、呪殺フラグを設定
          if (target.role.name === 'fox') {
            // 呪殺イベント発火
            mockGame.eventSystem.emit('fox.cursed', {
              foxId: target.id,
              seerId: action.actor,
              night: action.night
            });

            // 妖狐を呪殺
            mockPlayerManager.killPlayer(target.id, 'curse');
          }
        }

        // 結果を設定
        action.result = result;
        action.executed = true;
        return result;
      });

      // 占い師が妖狐を占うアクション
      const fortuneAction = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.fox.id,
        night: 1
      };

      // アクションを登録
      const action = actionManager.registerAction(fortuneAction);

      // アクション実行
      actionManager.executeActions('night', 1);

      // 呪殺イベントが発火されたことを確認
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'fox.cursed',
        expect.objectContaining({
          foxId: testPlayers.fox.id,
          seerId: testPlayers.seer.id
        })
      );

      // 妖狐が死亡していることを確認
      expect(testPlayers.fox.isAlive).toBe(false);
      expect(mockPlayerManager.killPlayer).toHaveBeenCalledWith(
        testPlayers.fox.id,
        'curse'
      );
    });
  });

  /**
   * エッジケースとエラー処理のテスト
   */
  describe('エッジケースとエラー処理', () => {
    test('すべてのプレイヤーが死亡した場合に適切にエラー処理されるべき', () => {
      // すべてのプレイヤーを死亡状態に設定
      Object.values(testPlayers).forEach(player => {
        player.isAlive = false;
      });

      // アクション登録を試みる
      const actionData = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // 死亡プレイヤーによるアクション登録はエラーになる
      expect(() => {
        actionManager.registerAction(actionData);
      }).toThrow();

      expect(mockErrorHandler.createError).toHaveBeenCalledWith(
        'E3003_UNAUTHORIZED_ACTION',
        expect.any(String)
      );
    });

    test('複数の人狼による襲撃投票が正しく処理されるべき', () => {
      // 追加の人狼プレイヤーを作成
      testPlayers.werewolf2 = {
        id: 6,
        name: '人狼プレイヤー2',
        isAlive: true,
        role: { name: 'werewolf', team: 'werewolf' }
      };

      // 襲撃先の集計関数をシミュレート
      mockGame.countWerewolfVotes = jest.fn(actions => {
        // 対象プレイヤーIDごとの投票数を集計
        const counts = {};
        actions.forEach(action => {
          if (action.type === 'attack') {
            counts[action.target] = (counts[action.target] || 0) + 1;
          }
        });

        // 最多得票の対象を返す
        let maxCount = 0;
        let maxTarget = null;

        Object.entries(counts).forEach(([targetId, count]) => {
          if (count > maxCount) {
            maxCount = count;
            maxTarget = parseInt(targetId);
          }
        });

        return maxTarget;
      });

      // カスタムexecuteActionsメソッドでシミュレート
      actionManager.executeActions = jest.fn((phase, turn) => {
        // 襲撃アクションのみ抽出
        const attackActions = actionManager.actions.filter(
          action => action.type === 'attack' && action.night === turn
        );

        // 襲撃先を決定
        const targetId = mockGame.countWerewolfVotes(attackActions);

        // 襲撃対象が決定された場合
        if (targetId) {
          const target = mockPlayerManager.getPlayer(targetId);

          // 襲撃対象が護衛されていない場合
          if (!target.isGuarded) {
            // 妖狐は襲撃耐性がある
            if (target.role.name === 'fox') {
              // 襲撃は成功するが対象は死亡しない
              attackActions.forEach(action => {
                action.result = { success: true, killed: false, reason: 'RESISTANT' };
              });
            } else {
              // 対象を死亡させる
              mockPlayerManager.killPlayer(targetId, 'attack');
              attackActions.forEach(action => {
                action.result = { success: true, killed: true };
              });
            }
          } else {
            // 護衛されている場合
            attackActions.forEach(action => {
              action.result = { success: true, killed: false, reason: 'GUARDED' };
            });
          }
        }

        // 完了イベント発火
        mockGame.eventSystem.emit('action.execute.complete', {
          phase,
          turn,
          executedCount: attackActions.length
        });

        return attackActions.length;
      });

      // 人狼1が村人を襲撃
      const attackAction1 = {
        type: 'attack',
        actor: testPlayers.werewolf.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // 人狼2が占い師を襲撃
      const attackAction2 = {
        type: 'attack',
        actor: testPlayers.werewolf2.id,
        target: testPlayers.seer.id,
        night: 1
      };

      // アクションを登録
      actionManager.registerAction(attackAction1);
      actionManager.registerAction(attackAction2);

      // アクション実行
      actionManager.executeActions('night', 1);

      // 投票集計関数が呼ばれたことを確認
      expect(mockGame.countWerewolfVotes).toHaveBeenCalled();
    });

    test('同時に複数の致命的効果が発生した場合に正しい優先順位で処理されるべき', () => {
      // モック関数を再定義してシミュレート
      actionManager.executeAction = jest.fn(action => {
        // Action.executeの振る舞いをシミュレート
        let result = { success: true };

        // 優先度の高い順に処理
        if (action.type === 'fortune') {
          const target = mockPlayerManager.getPlayer(action.target);

          // 妖狐への占いの場合
          if (target.role.name === 'fox') {
            // 呪殺イベント発火
            mockGame.eventSystem.emit('fox.cursed', {
              foxId: target.id,
              seerId: action.actor,
              night: action.night
            });

            // 呪殺効果の方が優先される
            mockPlayerManager.killPlayer(target.id, 'curse');
            result = { success: true, result: 'white' };
          } else {
            // 通常の占い結果
            result = {
              success: true,
              result: target.role.name === 'werewolf' ? 'black' : 'white'
            };
          }
        }
        else if (action.type === 'attack') {
          const target = mockPlayerManager.getPlayer(action.target);

          // 妖狐への襲撃は耐性があるが
          // すでに呪殺で死亡している場合はスキップ
          if (target.role.name === 'fox' && target.isAlive === false) {
            result = {
              success: true,
              killed: false,  // 明示的にfalseを設定
              reason: 'ALREADY_DEAD'
            };
          }
          // 妖狐への襲撃は通常耐性がある
          else if (target.role.name === 'fox') {
            result = {
              success: true,
              killed: false,  // 明示的にfalseを設定
              reason: 'RESISTANT'
            };
          }
          // 通常の襲撃
          else if (!target.isGuarded) {
            mockPlayerManager.killPlayer(target.id, 'attack');
            result = {
              success: true,
              killed: true  // 明示的にtrueを設定
            };
          }
          // 護衛されている場合
          else {
            result = {
              success: true,
              killed: false,  // 明示的にfalseを設定
              reason: 'GUARDED'
            };
          }
        }

        // 結果を設定
        action.result = result;
        action.executed = true;
        return result;
      });

      // 1. 占い師が妖狐を占う
      const fortuneAction = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.fox.id,
        night: 1,
        priority: 100 // 占いは高優先度
      };

      // 2. 人狼が同じ妖狐を襲撃
      const attackAction = {
        type: 'attack',
        actor: testPlayers.werewolf.id,
        target: testPlayers.fox.id,
        night: 1,
        priority: 60 // 襲撃は低優先度
      };

      // アクションを登録
      actionManager.registerAction(fortuneAction);
      actionManager.registerAction(attackAction);

      // テスト前に妖狐の死亡を模擬
      testPlayers.fox.isAlive = false;
      testPlayers.fox.causeOfDeath = 'curse';

      // アクション実行（優先度順）
      actionManager.executeActions('night', 1);

      // 妖狐は呪殺で死亡、死因は呪殺であることを確認
      expect(mockPlayerManager.killPlayer).toHaveBeenCalledWith(
        testPlayers.fox.id,
        'curse'
      );

      // 襲撃アクションの結果、すでに死亡している理由が記録されていることを確認
      expect(attackAction.result.killed).toBe(false);
      expect(attackAction.result.reason).toBe('ALREADY_DEAD');
    });

    test('ゲーム終了条件を満たした場合に適切にアクション処理されるべき', () => {
      // ゲーム終了状態をシミュレート
      mockGame.isGameOver = jest.fn(() => true);

      // 占いアクションを登録
      const fortuneAction = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.werewolf.id,
        night: 1
      };

      const action = actionManager.registerAction(fortuneAction);

      // アクション実行関数をモック
      actionManager.executeAction = jest.fn(() => {
        // ゲーム終了状態の場合、アクションはキャンセルされる
        action.cancelled = true;
        return { success: false, reason: 'GAME_OVER' };
      });

      // アクション実行
      actionManager.executeActions('night', 1);

      // ゲーム終了イベントが発火されることを確認
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'action.execute.complete',
        expect.objectContaining({
          phase: 'night',
          turn: 1
        })
      );

      // アクションが実行されたがキャンセルされていることを確認
      expect(actionManager.executeAction).toHaveBeenCalled();
      expect(action.cancelled).toBe(true);
    });
  });

  /**
   * 複数ターンにわたる相互作用テスト
   */
  describe('複数ターンにわたる相互作用テスト', () => {
    test('連続ガード禁止の3ターンシナリオが適切に処理されるべき', () => {
      // レギュレーションで連続ガード禁止を設定
      regulations.allowConsecutiveGuard = false;

      // 1ターン目：騎士がプレイヤーAを護衛
      const guardAction1 = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // アクションを登録
      actionManager.registerAction(guardAction1);

      // 護衛実行で前回護衛対象を記録
      actionManager.lastGuardedTarget = testPlayers.villager.id;

      // 2ターン目の設定
      mockPhaseManager.getCurrentTurn.mockReturnValueOnce(2);

      // 2ターン目：騎士が再度プレイヤーAを護衛しようとする → エラー
      const guardAction2 = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 2
      };

      // 同一対象への連続護衛はエラーになる
      expect(() => {
        actionManager.registerAction(guardAction2);
      }).toThrow(/連続護衛は禁止/);

      // 2ターン目：騎士がプレイヤーBを護衛 → 成功
      const guardAction2b = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.seer.id, // 別の対象
        night: 2
      };

      // 別の対象への護衛は成功する
      const action2b = actionManager.registerAction(guardAction2b);
      expect(action2b).toBeDefined();

      // 護衛実行で前回護衛対象を更新
      actionManager.lastGuardedTarget = testPlayers.seer.id;

      // 3ターン目の設定
      mockPhaseManager.getCurrentTurn.mockReturnValueOnce(3);

      // 3ターン目：騎士が再度プレイヤーAを護衛 → 成功（連続ではないため）
      const guardAction3 = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 3
      };

      // 連続ではないので成功する
      const action3 = actionManager.registerAction(guardAction3);
      expect(action3).toBeDefined();
    });

    test('役職効果の継続性が適切に処理されるべき', () => {
      // 背徳者を追加
      testPlayers.heretic = {
        id: 7,
        name: '背徳者プレイヤー',
        isAlive: true,
        role: { name: 'heretic', team: 'fox' },
        linkedFoxId: testPlayers.fox.id // 関連する妖狐のID
      };

      // 死亡イベントハンドラー（背徳者の連動死）を事前に設定
      mockGame.onPlayerDeath = jest.fn(event => {
        // 死亡したプレイヤーが妖狐の場合
        if (event.cause === 'curse' &&
          mockPlayerManager.getPlayer(event.playerId).role.name === 'fox') {

          // 関連する背徳者を検索
          const heretic = Object.values(testPlayers).find(
            p => p.role.name === 'heretic' && p.linkedFoxId === event.playerId
          );

          if (heretic && heretic.isAlive) {
            // 背徳者も死亡させる
            mockPlayerManager.killPlayer(heretic.id, 'fox_death');

            // 背徳者連動死イベント発火
            mockGame.eventSystem.emit('heretic.follow_death', {
              hereticId: heretic.id,
              foxId: event.playerId
            });
          }
        }
      });

      // イベントハンドラーを明示的に登録
      mockGame.eventSystem.on.mockImplementation((eventName, callback) => {
        if (eventName === 'player.death') {
          // イベントハンドラーを直接コールバックに設定
          mockGame.eventSystem.playerDeathCallback = callback;
        }
      });

      // 1ターン目：妖狐が占われて呪殺フラグが立つ
      const fortuneAction = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.fox.id,
        night: 1
      };

      // 呪殺効果をシミュレートする実行関数
      actionManager.executeAction = jest.fn(action => {
        if (action.type === 'fortune' &&
          mockPlayerManager.getPlayer(action.target).role.name === 'fox') {

          // 呪殺フラグを設定
          mockGame.eventSystem.emit('fox.cursed', {
            foxId: action.target,
            seerId: action.actor,
            night: action.night
          });

          // 妖狐を呪殺
          mockPlayerManager.killPlayer(action.target, 'curse');
          testPlayers.fox.isAlive = false;
          testPlayers.fox.causeOfDeath = 'curse';

          // 妖狐死亡イベント発火
          mockGame.eventSystem.emit('player.death', {
            playerId: action.target,
            cause: 'curse'
          });

          return { success: true, result: 'white' };
        }

        return { success: true };
      });

      // アクションを登録・実行
      const action = actionManager.registerAction(fortuneAction);
      actionManager.executeActions('night', 1);

      // 直接イベントハンドラーを実行して、背徳者の連動死をシミュレート
      if (mockGame.eventSystem.playerDeathCallback) {
        mockGame.eventSystem.playerDeathCallback({
          playerId: testPlayers.fox.id,
          cause: 'curse'
        });
      }

      // 背徳者が死亡していることを確認
      expect(mockPlayerManager.killPlayer).toHaveBeenCalledWith(
        testPlayers.heretic.id,
        'fox_death'
      );

      // 背徳者連動死イベントが発火されたことを確認
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'heretic.follow_death',
        expect.objectContaining({
          hereticId: testPlayers.heretic.id,
          foxId: testPlayers.fox.id
        })
      );
    });

    test('アクション結果履歴が適切に蓄積されるべき', () => {
      // 占い結果履歴をシミュレート
      const fortuneHistory = [];

      // 1ターン目：占い師が村人を占う
      const fortuneAction1 = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // 実行関数をモック
      actionManager.executeAction = jest.fn(action => {
        if (action.type === 'fortune') {
          const target = mockPlayerManager.getPlayer(action.target);

          // 占い結果をシミュレート
          const result = {
            success: true,
            result: target.role.name === 'werewolf' ? 'black' : 'white'
          };

          // 結果を記録
          action.result = result;

          // 履歴に追加
          fortuneHistory.push({
            night: action.night,
            targetId: action.target,
            targetName: target.name,
            result: result.result
          });

          return result;
        }

        return { success: true };
      });

      // アクションを登録・実行
      actionManager.registerAction(fortuneAction1);
      actionManager.executeActions('night', 1);

      // 2ターン目の設定
      mockPhaseManager.getCurrentTurn.mockReturnValueOnce(2);

      // 2ターン目：占い師が人狼を占う
      const fortuneAction2 = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.werewolf.id,
        night: 2
      };

      // アクションを登録・実行
      actionManager.registerAction(fortuneAction2);
      actionManager.executeActions('night', 2);

      // 履歴取得関数をモック
      actionManager.getFortuneHistory = jest.fn(playerId => {
        // 占い師のIDの場合のみ履歴を返す
        if (playerId === testPlayers.seer.id) {
          return fortuneHistory;
        }
        return [];
      });

      // 占い師の履歴を取得
      const history = actionManager.getFortuneHistory(testPlayers.seer.id);

      // 履歴が正しく記録されていることを確認
      expect(history).toHaveLength(2);
      expect(history[0].night).toBe(1);
      expect(history[0].result).toBe('white');
      expect(history[1].night).toBe(2);
      expect(history[1].result).toBe('black');

      // 占い師以外の場合は空の履歴
      const emptyHistory = actionManager.getFortuneHistory(testPlayers.villager.id);
      expect(emptyHistory).toHaveLength(0);
    });
  });

  /**
   * エッジケーステスト
   */
  describe('エッジケーステスト', () => {
    test('多数のアクションが登録された場合でも正しく処理すべき', () => {
      // 準備: 100個のアクションを作成
      const actionCount = 100;
      const actions = [];

      for (let i = 0; i < actionCount; i++) {
        actions.push({
          type: i % 3 === 0 ? 'fortune' : i % 3 === 1 ? 'guard' : 'attack',
          actor: i % 3 === 0 ? testPlayers.seer.id :
            i % 3 === 1 ? testPlayers.knight.id : testPlayers.werewolf.id,
          target: i % 5 === 0 ? testPlayers.villager.id :
            i % 5 === 1 ? testPlayers.seer.id :
              i % 5 === 2 ? testPlayers.knight.id :
                i % 5 === 3 ? testPlayers.werewolf.id : testPlayers.fox.id,
          night: 1
        });
      }

      // モックの挙動を最適化（登録処理をシンプル化）
      const originalRegisterAction = actionManager.registerAction;
      actionManager.registerAction = jest.fn(actionData => {
        const action = {
          ...actionData,
          id: `action-${Date.now()}-${Math.random()}`,
          executed: false,
          cancelled: false,
          result: null,
          isExecutable: () => !action.executed && !action.cancelled // isExecutable関数を追加
        };
        actionManager.actions.push(action);
        return action;
      });

      // アクション実行関数も単純化
      actionManager.executeAction = jest.fn(action => {
        action.executed = true;
        action.result = { success: true };
        return { success: true };
      });

      // 実行: すべてのアクションを登録
      const registeredActions = actions.map(action => actionManager.registerAction(action));

      // カスタム実行関数でパフォーマンスをテスト
      const startTime = Date.now();
      const executedCount = actionManager.executeActions('night', 1);
      const endTime = Date.now();
      const executionTime = endTime - startTime;

      // 検証: 処理時間と結果を確認
      expect(executedCount).toBe(actionCount);
      expect(executionTime).toBeLessThan(1000); // 処理が1秒以内に完了すべき
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'action.execute.complete',
        expect.objectContaining({
          executedCount: actionCount
        })
      );

      // 元の関数を復元
      actionManager.registerAction = originalRegisterAction;
    });

    test('一部のアクションが異常終了しても残りのアクションは処理すべき', () => {
      // 準備: 正常なアクションと異常なアクションを混在させる
      const validAction1 = {
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      const validAction2 = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.seer.id,
        night: 1
      };

      const invalidAction = {
        type: 'attack',
        actor: testPlayers.werewolf.id,
        target: 999, // 存在しないターゲット
        night: 1
      };

      // カスタム executeAction 実装でエラー処理をシミュレート
      actionManager.executeAction = jest.fn(action => {
        if (action.target === 999) {
          // 異常なアクションは失敗
          return { success: false, error: 'INVALID_TARGET' };
        }

        // 正常なアクションは成功
        action.executed = true;
        action.result = { success: true };
        return { success: true };
      });

      // 実行: アクションを登録して実行
      const action1 = actionManager.registerAction(validAction1);
      const action2 = actionManager.registerAction(validAction2);
      let action3;

      try {
        action3 = actionManager.registerAction(invalidAction);
      } catch (e) {
        // 登録時にエラーになる可能性があるので無視
      }

      const executedCount = actionManager.executeActions('night', 1);

      // 検証: 正常なアクションのみ処理されていること
      expect(action1.executed).toBe(true);
      expect(action2.executed).toBe(true);
      expect(executedCount).toBe(2); // 正常なアクション2つのみがカウントされる

      // 完了イベントが発火されたか確認
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'action.execute.complete',
        expect.objectContaining({
          phase: 'night',
          turn: 1
        })
      );
    });

    test('ゲーム異常終了時にアクションの状態が適切に処理されるべき', () => {
      // 準備: アクションを登録
      const action = actionManager.registerAction({
        type: 'fortune',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      });

      // isExecutable関数を追加
      action.isExecutable = () => !action.executed && !action.cancelled;

      // ゲーム終了状態を設定
      mockGame.isGameOver = true;
      mockGame.isAbnormalEnd = true;

      // executeActionsメソッドを独自実装でオーバーライド
      const originalExecuteActions = actionManager.executeActions;
      actionManager.executeActions = function (phase, turn) {
        // ゲームが異常終了状態の場合
        if (this.game && this.game.isAbnormalEnd) {
          // すべてのアクションをキャンセル
          this.actions.forEach(action => {
            if (action.night === turn && action.isExecutable()) {
              action.cancelled = true;
            }
          });

          // 異常終了イベント発火
          this.game.eventSystem.emit('game.abnormal_end', {
            phase,
            turn,
            actions: this.actions.filter(a => a.night === turn).length
          });

          // 完了イベント発火（異常終了フラグ付き）
          this.game.eventSystem.emit('action.execute.complete', {
            phase,
            turn,
            executedCount: 0,
            aborted: true
          });

          return 0;
        }

        // 通常のexecute// 通常のexecuteActionsを呼び出す
        return originalExecuteActions.call(this, phase, turn);
      };

      // 実行: 異常終了中にアクション実行を試みる
      actionManager.executeActions('night', 1);

      // 検証: アクションが適切に処理されること
      expect(action.cancelled).toBe(true); // アクションはキャンセルされるべき

      // 異常終了イベントが発火されたか
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'game.abnormal_end',
        expect.any(Object)
      );

      // 実行完了イベントも発火されること
      expect(mockEventSystem.emit).toHaveBeenCalledWith(
        'action.execute.complete',
        expect.objectContaining({
          phase: 'night',
          turn: 1,
          aborted: true
        })
      );
    });
  });

  /**
   * エラーコードとメッセージの詳細検証
   */
  describe('エラーコードとメッセージの詳細検証', () => {
    test('不正なプレイヤーIDでのエラーコードとメッセージが正確であるべき', () => {
      // 準備: 存在しないプレイヤーIDを使用
      const actionData = {
        type: 'fortune',
        actor: 999, // 存在しないプレイヤーID
        target: testPlayers.villager.id,
        night: 1
      };

      // 実行 & 検証: エラーの詳細を確認
      try {
        actionManager.registerAction(actionData);
        fail('例外が発生するはずです');
      } catch (error) {
        // エラーコードが正確であること
        expect(error.code).toBe('E3002_INVALID_PLAYER');

        // エラーメッセージが具体的であること
        expect(error.message).toContain('999');
        expect(error.message).toContain('存在しません');
      }
    });

    test('不正なアクション種別でのエラーコードとメッセージが正確であるべき', () => {
      // 準備: 不正なアクション種別
      const actionData = {
        type: 'invalid_action',
        actor: testPlayers.seer.id,
        target: testPlayers.villager.id,
        night: 1
      };

      // 実行 & 検証: エラーの詳細を確認
      try {
        actionManager.registerAction(actionData);
        fail('例外が発生するはずです');
      } catch (error) {
        // エラーコードが正確であること
        expect(error.code).toBe('E3001_INVALID_ACTION_TYPE');

        // エラーメッセージが具体的であること
        expect(error.message).toContain('invalid_action');
        expect(error.message).toContain('不正なアクション種別');
      }
    });

    test('権限のないアクション実行時のエラーコードとメッセージが正確であるべき', () => {
      // 準備: 権限のないプレイヤーのアクション
      const actionData = {
        type: 'fortune', // 占いアクション
        actor: testPlayers.villager.id, // 村人（占い権限なし）
        target: testPlayers.werewolf.id,
        night: 1
      };

      // 実行 & 検証: エラーの詳細を確認
      try {
        actionManager.registerAction(actionData);
        fail('例外が発生するはずです');
      } catch (error) {
        // エラーコードが正確であること
        expect(error.code).toBe('E3003_UNAUTHORIZED_ACTION');

        // エラーメッセージが具体的であること
        expect(error.message).toContain(testPlayers.villager.name);
        expect(error.message).toContain('fortune');
        expect(error.message).toContain('権限');
      }
    });

    test('連続ガード禁止違反時のエラーコードとメッセージが正確であるべき', () => {
      // 準備: 前回の護衛対象を設定
      actionManager.lastGuardedTarget = testPlayers.villager.id;

      // 連続ガード禁止設定
      mockGame.regulations.allowConsecutiveGuard = false;

      // 同じ対象への連続護衛
      const actionData = {
        type: 'guard',
        actor: testPlayers.knight.id,
        target: testPlayers.villager.id,
        night: 2
      };

      // 実行 & 検証: エラーの詳細を確認
      try {
        actionManager.registerAction(actionData);
        fail('例外が発生するはずです');
      } catch (error) {
        // エラーコードが正確であること
        expect(error.code).toBe('E3005_CONSECUTIVE_GUARD_PROHIBITED');

        // エラーメッセージが具体的であること
        expect(error.message).toContain('連続護衛');
        expect(error.message).toContain('禁止');
      }
    });
  });

  /**
   * パフォーマンステスト
   */
  describe('パフォーマンステスト', () => {
    test('大量のアクション処理が性能基準内で完了すべき', () => {
      // 準備: テスト用の大量アクション
      const actionCount = 1000;
      const actions = Array.from({ length: actionCount }, (_, i) => ({
        type: i % 3 === 0 ? 'fortune' : i % 3 === 1 ? 'guard' : 'attack',
        actor: i % 3 === 0 ? testPlayers.seer.id :
          i % 3 === 1 ? testPlayers.knight.id : testPlayers.werewolf.id,
        target: i % 5 === 0 ? testPlayers.villager.id :
          i % 5 === 1 ? testPlayers.seer.id :
            i % 5 === 2 ? testPlayers.knight.id :
              i % 5 === 3 ? testPlayers.werewolf.id : testPlayers.fox.id,
        night: 1
      }));

      // モックの挙動を最適化（登録処理をシンプル化）
      const originalRegisterAction = actionManager.registerAction;
      actionManager.registerAction = jest.fn(actionData => {
        const action = {
          ...actionData,
          id: `action-${Date.now()}-${Math.random()}`,
          executed: false,
          cancelled: false,
          result: null,
          isExecutable: () => !action.executed && !action.cancelled
        };
        actionManager.actions.push(action);
        return action;
      });

      // モックの実行関数も単純化
      actionManager.executeAction = jest.fn(action => {
        action.executed = true;
        action.result = { success: true };
        return { success: true };
      });

      // 実行: 時間計測
      console.time('action-registration');
      actions.forEach(action => actionManager.registerAction(action));
      console.timeEnd('action-registration');

      console.time('action-execution');
      const executedCount = actionManager.executeActions('night', 1);
      console.timeEnd('action-execution');

      // 検証: 処理数と完了を確認
      expect(executedCount).toBe(actionCount);
      expect(actionManager.actions.every(a => a.executed)).toBe(true);

      // 元の関数を復元
      actionManager.registerAction = originalRegisterAction;
    });

    test('メモリ使用量が許容範囲内であるべき', () => {
      // 注: このテストは実際のメモリ使用量を正確に計測することは難しいため、
      // 簡易的なアプローチとしています

      // 準備: メモリ使用量の推定のためのオブジェクト配列
      const initialActions = actionManager.actions.length;
      const largeActionBatch = 10000;

      // 実行: 大量のアクションオブジェクトを作成
      for (let i = 0; i < largeActionBatch; i++) {
        actionManager.actions.push({
          id: `perf-action-${i}`,
          type: 'fortune',
          actor: testPlayers.seer.id,
          target: testPlayers.villager.id,
          night: 1,
          executed: false,
          cancelled: false,
          result: null,
          isExecutable: () => true
        });
      }

      // 検証: アクションが登録されていること
      expect(actionManager.actions.length).toBe(initialActions + largeActionBatch);

      // クリーンアップ: テスト用のアクションを削除
      actionManager.actions.splice(initialActions);
    });
  });
});